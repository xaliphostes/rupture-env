(function(){const Ae=document.createElement("link").relList;if(Ae&&Ae.supports&&Ae.supports("modulepreload"))return;for(const ut of document.querySelectorAll('link[rel="modulepreload"]'))gt(ut);new MutationObserver(ut=>{for(const Z of ut)if(Z.type==="childList")for(const ft of Z.addedNodes)ft.tagName==="LINK"&&ft.rel==="modulepreload"&&gt(ft)}).observe(document,{childList:!0,subtree:!0});function At(ut){const Z={};return ut.integrity&&(Z.integrity=ut.integrity),ut.referrerPolicy&&(Z.referrerPolicy=ut.referrerPolicy),ut.crossOrigin==="use-credentials"?Z.credentials="include":ut.crossOrigin==="anonymous"?Z.credentials="omit":Z.credentials="same-origin",Z}function gt(ut){if(ut.ep)return;ut.ep=!0;const Z=At(ut);fetch(ut.href,Z)}})();var li={exports:{}};/*! For license information please see dataframe.js.LICENSE.txt */var zi=li.exports,yi;function gi(){return yi||(yi=1,(function(le,Ae){(function(At,gt){le.exports=gt()})(typeof self<"u"?self:zi,(()=>(()=>{var At={d:(k,A)=>{for(var z in A)At.o(A,z)&&!At.o(k,z)&&Object.defineProperty(k,z,{enumerable:!0,get:A[z]})},o:(k,A)=>Object.prototype.hasOwnProperty.call(k,A),r:k=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(k,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(k,"__esModule",{value:!0})}},gt={};At.r(gt),At.d(gt,{DataFrame:()=>D,FunctionalDecomposer:()=>qe,Manager:()=>Ie,Matrix:()=>kt,Serie:()=>ct,Vector:()=>bt,_if:()=>ne,append:()=>Z,apply:()=>Ut,array:()=>Gt,check:()=>se,copy:()=>ee,createArray:()=>U,createEmptySerie:()=>R,createFrom:()=>O,createTyped:()=>at,cut:()=>me,duplicate:()=>Jt,exists:()=>Wt,filter:()=>Lt,forEach:()=>fe,getNameSeries:()=>Ne,info:()=>Xt,insertSerie:()=>ft,isNaN:()=>re,map:()=>wt,matrix:()=>Me,merge:()=>ut,nameOfSerie:()=>be,reduce:()=>Tt,remove:()=>J,sort:()=>vt,squaredMatrix:()=>pe,symSquaredMatrix:()=>ie,vector:()=>Ct});const ut=(k,A)=>{let z=k.reduce(((C,L)=>({...C,...L.series})),{}),M=k.reduce(((C,L)=>({...C,...L.userData})),{}),P=k.reduce(((C,L)=>({...C,...L.metaData})),{});return D.create({series:z,userData:M,metaData:P,index:A})},Z=({series:k,index:A,metaData:z,userData:M},P)=>D.create({series:{...k,...P},index:A,metaData:z,userData:M}),ft=({df:k,serie:A,name:z})=>{const M=Object.entries(k.series).map((([C,L])=>C)),P=M.length!==0?k.series[M[0]].count:0;if(P!==0&&A.count!==P)throw new Error("Provided serie count must be equal to existing series count");return k.series[z]=A,k},J=(k,A)=>k.remove(A);class D{forEach(A){Object.entries(this.series).forEach((([z,M],P)=>A(z,M,P)))}constructor(A,z,M,P){this.index=void 0,this.userData={},this.metaData={},this.series=A,this.index=z,this.userData=M,this.metaData=P}contains(A){return this.series[A]!==void 0}static create({series:A,userData:z,metaData:M,index:P}){return new D(A,P,z||{},M||{})}remove(A){const z=this.clone();return Array.isArray(A)?A.forEach((M=>{z.series.hasOwnProperty(M)&&delete z.series[M]})):z.series.hasOwnProperty(A)&&delete z.series[A],z}clone(){return new D(this.series,this.index,this.userData,this.metaData)}}function U(k,A){return A===void 0?new Array(k).fill(void 0):A instanceof Function?new Array(k).fill(void 0).map(((z,M)=>A(M))):new Array(k).fill(A)}function at(k,A,z){if(Array.isArray(A)){const M=A.length*k.BYTES_PER_ELEMENT;let P,C=typeof SharedArrayBuffer<"u";return P=new k(z&&C?new SharedArrayBuffer(M):new ArrayBuffer(M)),P.set(A),P}{const M=A*k.BYTES_PER_ELEMENT;return new k(z?new SharedArrayBuffer(M):new ArrayBuffer(M))}}function R({Type:k,count:A,itemSize:z=1,dimension:M=3,shared:P=!1,userData:C}){if(z<=0)throw new Error("itemSize must be > 0");if(A<=0)throw new Error("count must be > 0");if(k===void 0||Array.isArray(new k(1)))return ct.create({array:new Array(A*z).fill(0),itemSize:z});const L=A*z*k.BYTES_PER_ELEMENT;return P?ct.create({array:new k(new SharedArrayBuffer(L)),itemSize:z,userData:C,dimension:M}):ct.create({array:new k(new ArrayBuffer(L)),itemSize:z,userData:C,dimension:M})}class ct{constructor(A,z,M,P={},C=3){if(this.dimension=3,this.userData={},A.length%z!=0)throw new Error(`array length (${A.length}) is not a multiple of itemSize (${z})`);this.array=A,this.itemSize=z,this.shared=M,this.userData=P,this.dimension=C}static isSerie(A){return"array"in A&&"itemSize"in A}static create({array:A,itemSize:z,userData:M,dimension:P=3}){if(z<=0)throw new Error("itemSize must be > 0");if(A===void 0)throw new Error("array must be provided");if(typeof SharedArrayBuffer>"u")return new ct(A,z,!1,M,P);const C=A.buffer instanceof SharedArrayBuffer;return new ct(A,z,C,M,P)}get length(){return this.array.length}get count(){return this.array.length/this.itemSize}get isArray(){return Array.isArray(this.array)}get isArrayBuffer(){return this.isTypedArray}get isTypedArray(){return!this.isArray}get isShared(){return!this.isArray&&this.array.buffer instanceof SharedArrayBuffer}at(A){return this.array[A]}itemAt(A){const z=this.itemSize;if(z===1)return this.at(A);const M=A*z,P=new Array(z).fill(0);for(let C=0;C<z;++C)P[C]=this.array[M+C];return P}setItemAt(A,z){if(A>=this.count)throw new Error("array index out of bounds");const M=this.itemSize;if(M===1){if(Array.isArray(z))throw new Error("value must be a number");return void(this.array[A]=z)}const P=z;if(P.length!==M)throw new Error(`array length (${P.length}) must equals itemSize (${M})`);for(let C=0;C<M;++C)this.array[A*M+C]=z[C]}forEach(A){for(let z=0;z<this.count;++z)A(this.itemAt(z),z,this)}map(A){const z=A(this.itemAt(0),0,this),M=Array.isArray(z)?z.length:1,P=this.image(this.count,M);let C=0;for(let L=0;L<this.count;++L){const zt=A(this.itemAt(L),L,this);if(M===1)P.array[C++]=zt;else for(let xt=0;xt<M;++xt)P.array[C++]=zt[xt]}return P}clone(A=!1){const z=new ct(this.array.slice(0,this.count*this.itemSize),this.itemSize,this.shared,this.userData,this.dimension);return A&&z.array.forEach(((M,P)=>z.array[P]=0)),z}newInstance({count:A,itemSize:z,initialize:M=!0}){const P=new ct(O({array:this.array,count:A,itemSize:z}),z,this.shared,this.userData,this.dimension);if(M)for(let C=0;C<P.array.length;++C)P.array[C]=0;return P}image(A,z){return this.newInstance({count:A,itemSize:z})}}function O({array:k,count:A,itemSize:z}){const M=A*z;if(Array.isArray(k))return new Array(M);let P=!1;return typeof SharedArrayBuffer<"u"&&(P=k.buffer instanceof SharedArrayBuffer),k instanceof Int8Array?at(Int8Array,M,P):k instanceof Uint8Array?at(Uint8Array,M,P):k instanceof Uint8ClampedArray?at(Uint8ClampedArray,M,P):k instanceof Int16Array?at(Int16Array,M,P):k instanceof Uint16Array?at(Uint16Array,M,P):k instanceof Int32Array?at(Int32Array,M,P):k instanceof Uint32Array?at(Uint32Array,M,P):k instanceof Float32Array?at(Float32Array,M,P):k instanceof Float64Array?at(Float64Array,M,P):k instanceof BigInt64Array?at(BigInt64Array,M,P):k instanceof BigUint64Array?at(BigUint64Array,M,P):void 0}const wt=(k,A)=>{if(Array.isArray(k)){let z,M=!0,P=0;const C=k[0].count,L=new Array(k.length);for(let zt=0;zt<C;++zt){for(let Ot=0;Ot<k.length;++Ot)L[Ot]=k[Ot].itemAt(zt);const xt=A(L);z===void 0&&(M=Array.isArray(xt),z=k[0].image(C,M?xt.length:1)),M?xt.forEach((Ot=>z.array[P++]=Ot)):z.array[P++]=xt}return z}return k.map(A)},Lt=(k,A)=>{if(k===void 0)throw new Error("serie is undefined");const z=k.count,M=[];for(let C=0;C<z;++C){const L=k.itemAt(C);A(L,C,k)&&M.push(L)}const P=k.array.slice(0,M.length);return M.forEach(((C,L)=>P[L]=C)),ct.create({array:P,itemSize:k.itemSize})},fe=(k,A)=>{if(k===void 0)throw new Error("serie is undefined");if(!Array.isArray(k)){for(let M=0;M<k.count;++M)A(k.itemAt(M),M,k);return}let z=k[0].count;for(let M=0;M<z;++M)A(k.map((P=>P.itemAt(M))),M,k)},Tt=function(k,A,z){if(Array.isArray(k)){const M=k[0].count;for(let P=0;P<M;++P)z=A(z,k.map((C=>C.itemAt(P))));return z}return k.forEach((M=>z=A(z,M))),z},Ut=(k,A)=>k.map(((z,M)=>A(z,M,k))),vt=(k,A=((z,M)=>z-M))=>{if(k.itemSize!==1)throw new Error("sort algorithm: itemSize must be 1");const z=k.clone(!1);return z.array.sort(A),z},me=(k,A)=>{if(k===void 0)throw new Error("serie is undefined");if(k.itemSize!==1)throw new Error("serie should have itemSize = 1");return Lt(k,A)},Wt=(k,A)=>k.series[A]!==void 0,Xt=k=>{if(ct.isSerie(k)){const z=k;return{isArray:z.isArray,isBuffer:z.isArrayBuffer,isShared:z.shared,length:z.length,count:z.count,itemSize:z.itemSize,dimension:z.dimension,array:z.array}}const A=k;return{userData:A.userData,series:Object.entries(A.series).map((([z,M])=>({name:z,userData:M.userData,isArray:M.isArray,isBuffer:M.isArrayBuffer,isShared:M.shared,length:M.length,count:M.count,itemSize:M.itemSize,dimension:M.dimension,array:M.array})))}};var Gt;(function(k){function A(z){let M=Number.POSITIVE_INFINITY,P=Number.NEGATIVE_INFINITY;const C=z.length;for(let L=0;L<C;++L){const zt=z[L];zt<M&&(M=zt),zt>P&&(P=zt)}return[M,P]}k.min=function(z){let M=Number.POSITIVE_INFINITY;const P=z.length;for(let C=0;C<P;++C){const L=z[C];L<M&&(M=L)}return M},k.max=function(z){let M=Number.NEGATIVE_INFINITY;const P=z.length;for(let C=0;C<P;++C){const L=z[C];L>M&&(M=L)}return M},k.minMax=A,k.normalize=function(z){const M=A(z);return z.map((P=>(P-M[0])/(M[1]-M[0])))},k.scale=function(z,M){return z.map((P=>P*M))},k.dectectNan=function(z){return z.map(((M,P)=>({value:M,i:P}))).filter((M=>Number.isNaN(M.value))).map((M=>M.i))},k.flatten=function(z){const M=[];return z.forEach((P=>M.push(...P))),M}})(Gt||(Gt={}));const ee=(k,A)=>{if(ct.isSerie(k)){const z=k;if(A.array.length!==z.array.length)throw new Error("length mismatch for both series");z.array.forEach(((M,P)=>A.array[P]=M))}else{if(A.array.length!==k.length)throw new Error("Array and Serie length mismatch");k.forEach(((z,M)=>A.array[M]=z))}return A},Jt=k=>k.clone(!1),be=(k,A)=>Object.entries(k.series).reduce(((z,[M,P])=>A===P?M:z),void 0),Ne=k=>Object.entries(k.series).map((([A,z])=>A)),Ct=k=>new bt(k);class bt{constructor(A){this.v=A}at(A){return this.v[A]}get length(){return this.v.length}get array(){return this.v}normalize(){const A=this.norm();return this.v=this.v.map((z=>z/A)),this}norm(){return Math.sqrt(this.v.reduce(((A,z)=>A+z**2),0))}mult(A){return this.v=this.v.map((z=>z*A)),this}add(A){return this.v=A.v.map(((z,M)=>this.v[M]+=z)),this}sub(A){return this.v=A.v.map(((z,M)=>this.v[M]-=z)),this}dot(A){return this.array.reduce(((z,M,P)=>z+M*A.array[P]),0)}toString(){let A="";for(let z=0;z<this.length;++z)A+=this.at(z)+"	";return A}}const Me=k=>pe(k),pe=k=>{const A=Math.sqrt(k.length);if(!Number.isInteger(A))throw new Error(`squared matrix requires m*m coefficients (got m=${k.length})`);return new kt(k,A)},ie=k=>{const A=(Math.sqrt(8*k.length+1)-1)/2;if(!Number.isInteger(A))throw new Error(`symmetric squared matrix of dim m requires (m*(m+1)/2) coefficients (got ${k.length}`);const z=(C,L)=>C*A+L,M=(C,L)=>L<C?.5*L*(2*A-1-L)+C:.5*C*(2*A-1-C)+L,P=new Array(A*A).fill(0);for(let C=0;C<A;++C)for(let L=0;L<A;++L)P[z(L,C)]=k[M(C,L)];return new kt(P,A)};class kt{constructor(A,z){this.v=A,this.m=z}index(A,z){return A*this.m+z}get isSymmetric(){let A=!0;for(let z=0;z<this.m;++z)for(let M=z;M<this.m;++M)A=A&&this.at(z,M)===this.at(M,z);return A}copy(){return new kt([...this.v],this.m)}at(A,z){return this.v[this.index(A,z)]}trace(){let A=0;for(let z=0;z<this.m;++z)A+=this.at(z,z);return A}set(A,z,M){return this.v[this.index(A,z)]=M,this}add(A,z,M){return this.v[this.index(A,z)]+=M,this}scale(A){return this.v=this.v.map((z=>z*A)),this}get length(){return this.v.length}get array(){if(this.isSymmetric){const A=new Array(this.m*(this.m+1)/2).fill(0);let z=0;for(let M=0;M<this.m;++M)for(let P=M;P<this.m;++P)A[z++]=this.at(M,P);return A}return[...this.v]}transpose(){const A=new Array(this.v.length).fill(0);let z=0;for(let M=0;M<this.m;++M)for(let P=0;P<this.m;++P)A[z++]=this.at(P,M);return new kt(A,this.m)}multVec(A){if(A.length!==this.m)throw new Error("size mismatch for product matrix vector");const z=new Array(A.length).fill(0),M=A instanceof bt?A.array:A;for(let P=0;P<this.m;++P)for(let C=0;C<this.m;++C)z[P]+=this.at(P,C)*M[C];return new bt(z)}multMat(A){if(A.m!==this.m)throw new Error("size mismatch for product matrix matrix");const z=new Array(A.length).fill(0);for(let M=0;M<this.m;++M)for(let P=0;P<this.m;++P)for(let C=0;C<this.m;++C)z[this.index(M,P)]+=this.at(M,C)*A.at(C,P);return new kt(z,this.m)}addMat(A){if(A.m!==this.m)throw new Error("sizes mismatch for adding matrix");for(let z=0;z<this.v.length;++z)this.v[z]+=A.v[z];return this}toString(){let A="";for(let z=0;z<this.m;++z){for(let M=0;M<this.m;++M)A+=this.at(z,M)+"	";A+=`
`}return A}}const re=k=>k.itemSize===1?k.map((A=>Number.isNaN(A))):k.map((A=>new Array(k.itemSize).fill(0).map((z=>Number.isNaN(z))))),se=(k,A)=>k.map((z=>!!A(z))),ne=(k,A,z,M)=>k.map(((P,C)=>A(P)===!0?z(P,C,k):M(P,C,k)));class Ie{constructor(A,z){this.df=A,this.ds_=[],this.dimension=3,z&&(Array.isArray(z)?(console.warn("Deprecated ctor for Manager"),this.ds_=z):(z.decomposers&&(this.ds_=z.decomposers),z.dimension&&(this.dimension=z.dimension)))}add(A){this.ds_.push(A)}clear(){this.ds_=[]}names(A){let z=new Set;return Object.entries(this.df.series).forEach((([M,P])=>{P.itemSize===A&&P.dimension===this.dimension&&M!=="positions"&&M!=="indices"&&z.add(M),this.ds_.forEach((C=>{C.names(this.df,A,P,M).forEach((L=>z.add(L)))}))})),Array.from(z)}contains(A,z){return this.names(A).includes(z)}serie(A,z){for(let[M,P]of Object.entries(this.df.series))if(P.itemSize===A&&z===M)return P.clone(!1);for(let M of this.ds_){const P=M.serie(this.df,A,z);if(P)return P}}}class qe{constructor(A,z,M){this.itemSize=A,this.name=z,this.fct=M}names(A,z,M,P){return z!==this.itemSize?[]:this.fct(A)?[this.name]:[]}serie(A,z,M){if(z===this.itemSize&&this.name===M)return this.fct(A)}}return gt})()))})(li)),li.exports}gi();var fi={exports:{}},Ei=fi.exports,wi;function Ai(){return wi||(wi=1,(function(le,Ae){(function(At,gt){le.exports=gt(gi())})(typeof self<"u"?self:Ei,(At=>(()=>{var gt={865:J=>{J.exports=At}},ut={};function Z(J){var D=ut[J];if(D!==void 0)return D.exports;var U=ut[J]={exports:{}};return gt[J](U,U.exports,Z),U.exports}Z.d=(J,D)=>{for(var U in D)Z.o(D,U)&&!Z.o(J,U)&&Object.defineProperty(J,U,{enumerable:!0,get:D[U]})},Z.o=(J,D)=>Object.prototype.hasOwnProperty.call(J,D),Z.r=J=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(J,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(J,"__esModule",{value:!0})};var ft={};return(()=>{Z.r(ft),Z.d(ft,{AreaDecomposer:()=>$e,ComponentDecomposer:()=>Ve,Eigen:()=>si,EigenValuesDecomposer:()=>Be,EigenVectorsDecomposer:()=>Pe,Fringes:()=>Re,IQR:()=>we,InterpolateDirection:()=>te,MinMax:()=>ht,NormalsDecomposer:()=>He,PositionDecomposer:()=>Oe,Quaternion:()=>It,ValenceDecomposer:()=>ti,VectorNormDecomposer:()=>Ze,abs:()=>Wt,add:()=>U,addNumber:()=>at,barycentric2:()=>Zt,barycentric3:()=>ve,barycentric4:()=>Se,biLerp:()=>ze,bins:()=>he,closeTo:()=>qe,covariance:()=>Ot,cross:()=>Gt,dectectNan:()=>yt,describe:()=>Pt,determinant:()=>L,div:()=>Lt,dot:()=>Xt,eigen:()=>de,eigenValue:()=>J,eigenVector:()=>D,equals:()=>Ie,flatten:()=>Ke,getNaN:()=>k,getRotationAxis:()=>Xe,inv:()=>A,inverseCDF:()=>ui,invert:()=>Ne,isOutliers:()=>oe,lerp:()=>Et,mat:()=>st,max:()=>ne,maxArray:()=>Ge,mean:()=>xt,meshInterpolate:()=>oi,min:()=>se,minArray:()=>je,minMax:()=>re,minMaxArray:()=>Ht,movingAverage:()=>Ft,mult:()=>ct,multMat:()=>wt,negate:()=>be,norm:()=>Tt,norm2:()=>Ut,normalize:()=>ee,normalizeArray:()=>Ye,notOutliers:()=>Qe,outliers:()=>Te,q25:()=>ye,q50:()=>Fe,q75:()=>Bt,quantile:()=>Vt,rand:()=>pe,randomMT:()=>hi,rotate:()=>z,rotateAxis:()=>ai,round:()=>ie,scale:()=>P,scaleArray:()=>St,shuffle:()=>C,square:()=>me,std:()=>xe,sub:()=>R,sum:()=>bt,switchConvention:()=>zt,tagNaN:()=>Me,tetraLerp:()=>ni,trace:()=>fe,translate:()=>M,transpose:()=>vt,triLerp:()=>Ue,triangleLerp2D:()=>Mt,triangleLerp3D:()=>Ce,trunc:()=>kt,unitInterval:()=>Jt,variance:()=>ge,vec:()=>mt,weightedMean:()=>Qt,weightedSum:()=>Ct});const J=l=>{if(l===void 0)throw new Error("series is undefined");const h=l.dimension;if((l.dimension!==2||l.itemSize!==3&&l.itemSize!==4)&&(l.dimension!==3||l.itemSize!==6&&l.itemSize!==9))throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${l.itemSize}`);const u=l.image(l.count,h),i=l.count;let r=0;for(let s=0;s<i;++s){const o=de(l.itemAt(s));for(let c=0;c<h;++c)u.array[r++]=o.values[c]}return u},D=l=>{if(l===void 0)throw new Error("series is undefined");const h=l.dimension;if((l.dimension!==2||l.itemSize!==3&&l.itemSize!==4)&&(l.dimension!==3||l.itemSize!==6&&l.itemSize!==9))throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${l.itemSize}`);const u=l.image(l.count,h**2),i=l.count;let r=0;for(let s=0;s<i;++s)de(l.itemAt(s)).vectors.forEach((o=>u.array[r++]=o));return u},U=l=>{if(l.length<=1)throw new Error("nb series should be greater than 1");const h=l[0].clone(!0);return l.forEach((u=>{if(u.length!==h.length)throw new Error(`size mistmatch. Cannot add 2 Series of different sizes (${u.length} != ${h.length})`);u.array.forEach(((i,r)=>h.array[r]+=i))})),h},at=(l,h)=>{const u=l.clone(!1);return h===0||u.array.forEach(((i,r)=>u.array[r]+=h)),u},R=(l,...h)=>{if(l===void 0)throw new Error("serie s is undefined");if(!h)throw new Error("cannot subtract undefined to s");const u=l.clone();return h&&h.forEach((i=>{if(typeof i=="number")u.array.forEach(((r,s)=>u.array[s]-=i));else{if(i.length!==l.length)throw new Error(`size mistmatch. Cannot add 2 Series of different sizes (${i.length} != ${l.length})`);i.array.forEach(((r,s)=>u.array[s]-=r))}})),u},ct=(l,...h)=>{if(l===void 0)return;if(!h)throw new Error("cannot multiply undefined to s");const u=l.clone();return h.forEach((i=>{if(typeof i=="number")u.array.forEach(((r,s)=>u.array[s]*=i));else{if(i.length!==l.length)throw new Error(`size mistmatch. Cannot multiply 2 Series of different sizes (${i.length} != ${l.length})`);i.array.forEach(((r,s)=>u.array[s]*=r))}})),u};var O=Z(865);const wt=(l,h)=>{if(l===void 0)throw new Error("s1 is undefined");if(h===void 0)throw new Error("s2 is undefined");if(typeof h=="number")return ct(l,h);if(h.itemSize===1)return l.map(((u,i)=>u*h.itemAt(i)));if(l.itemSize===1){if(h.itemSize!==1)throw new Error("s2 should have itemSize=1 (same as s1)");return l.map(((u,i)=>u*h.itemAt(i)))}if(l.itemSize===3){if(h.itemSize===3)return l.map(((u,i)=>{const r=h.itemAt(i);return u[0]*r[0]+u[1]*r[1]+u[2]*r[2]}));throw new Error("since s1 has itemSize=3, s2 should have itemSize=1 or 3")}if(l.itemSize===6||l.itemSize===9){if(h.itemSize===3)return l.map(((u,i)=>{const r=l.itemSize===6?(0,O.symSquaredMatrix)(u):(0,O.squaredMatrix)(u),s=new O.Vector(h.itemAt(i));return r.multVec(s).array}));if(h.itemSize===6||h.itemSize===9)return l.map(((u,i)=>{const r=l.itemSize===6?(0,O.symSquaredMatrix)(u):(0,O.squaredMatrix)(u),s=h.itemSize===6?(0,O.symSquaredMatrix)(h.itemAt(i)):(0,O.squaredMatrix)(h.itemAt(i));return r.multMat(s).array}))}throw new Error("Cannot multMat")},Lt=(l,...h)=>{if(l===void 0)return;if(!h)throw new Error("cannot divide undefined to s");const u=l.clone();return h&&h.forEach((i=>{if(typeof i=="number")u.array.forEach(((r,s)=>u.array[s]/=i));else{if(i.length!==l.length)throw new Error(`size mistmatch. Cannot divide 2 Series of different sizes (${i.length} != ${l.length})`);i.array.forEach(((r,s)=>u.array[s]/=r))}})),u};function fe(l){if(l===void 0)throw new Error("series is undefined");if(l.itemSize!==1&&l.itemSize!==3&&l.itemSize!==4&&l.itemSize!==6&&l.itemSize!==9)throw new Error("item size should be 1, 3, 4, 6 or 9");if(l.itemSize===1)return l.clone();const h=l.itemSize,u=l.image(l.count,1);for(let i=0;i<l.count;++i){const r=l.itemAt(i);u.array[i]=h===3?r[0]+r[2]:h===4?r[0]+r[3]:h===6?r[0]+r[3]+r[5]:r[0]+r[4]+r[8]}return u}const Tt=l=>Ut(l).map((h=>Math.sqrt(h))),Ut=l=>{if(l===void 0)throw new Error("series is undefined");const h=l.image(l.count,1);if(l.itemSize===1)return h;for(let u=0;u<l.count;++u){const i=l.itemAt(u);h.array[u]=i.reduce(((r,s)=>r+s**2),0)}return h},vt=l=>{if(l===void 0)return;if(l.itemSize!==9)throw new Error("items size should be 9 only (for now)");const h=l.clone(),u=h.array;let i=0;return l.forEach((r=>{u[i++]=r[0],u[i++]=r[3],u[i++]=r[6],u[i++]=r[1],u[i++]=r[4],u[i++]=r[7],u[i++]=r[2],u[i++]=r[5],u[i++]=r[8]})),h},me=l=>{if(l===void 0)throw new Error("series is undefined");return O.Serie.create({array:l.array.map((h=>h**2)),itemSize:l.itemSize,dimension:l.dimension})},Wt=l=>{if(l===void 0)throw new Error("series is undefined");return O.Serie.create({array:l.array.map((h=>Math.abs(h))),itemSize:l.itemSize,dimension:l.dimension})},Xt=(l,h)=>{if(l===void 0)throw new Error("serie a is undefined");if(h===void 0)throw new Error("serie or Vector b is undefined");return O.Serie.isSerie(h)===!0?(0,O.map)([l,h],(([u,i])=>(0,O.vector)(u).dot((0,O.vector)(i)))):(0,O.map)(l,(u=>(0,O.vector)(u).dot((0,O.vector)(h))))},Gt=(l,h)=>{if(l===void 0)throw new Error("serie A is undefined");if(h===void 0)throw new Error("serie B is undefined");if(l.itemSize!==3)throw new Error("cross only supports itemSize=3");if(h.itemSize!==3)throw new Error("cross only supports itemSize=3");return l.map(((u,i)=>{const r=h.itemAt(i);return[u[1]*r[2]-u[2]*r[1],u[2]*r[0]-u[0]*r[2],u[0]*r[1]-u[1]*r[0]]}))},ee=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize===1){const h=O.array.minMax(l.array),u=h[0],i=1/(h[1]-u);return l.map((r=>i*(r-u)))}return l.map((h=>{const u=1/Math.sqrt(h.reduce(((i,r)=>i+r*r),0));return h.map((i=>i*u))}))},Jt=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize===1){const h=O.array.minMax(l.array),u=h[0],i=1/(h[1]-u);return l.map((r=>i*(r-u)))}return l.map((h=>{const u=O.array.minMax(h),i=u[0],r=1/(u[1]-i);return h.map((s=>r*(s-i)))}))},be=l=>{if(l===void 0)throw new Error("series is undefined");return O.Serie.create({array:l.array.map((h=>-h)),itemSize:l.itemSize,dimension:l.dimension})},Ne=l=>{if(l===void 0)throw new Error("series is undefined");return O.Serie.create({array:l.array.map((h=>1/h)),itemSize:l.itemSize,dimension:l.dimension})},Ct=(l,h)=>{if(h.length!==l.length)throw new Error(`data length (${l.length}) should be equal to alpha length (${h.length})`);return U(l.map(((u,i)=>ct(u,h[i]))))},bt=l=>{if(l.itemSize===1){let u=0;return l.forEach((i=>u+=i)),u}const h=new Array(l.itemSize).fill(0);return l.forEach((u=>u.forEach(((i,r)=>h[r]+=i)))),h},Me=(l,h)=>l.itemSize===1?l.map(((u,i)=>h(u,i,l)?Number.NaN:u)):l.map(((u,i)=>h(u,i,l)?new Array(l.itemSize).fill(Number.NaN):u)),pe=(l,h=0,u=1)=>{const i=u-h;return l.itemSize===1?l.map((()=>h+i*Math.random())):l.map((()=>new Array(l.itemSize).fill(0).map((()=>h+i*Math.random()))))},ie=l=>l.itemSize===1?l.map((h=>Math.round(h))):l.map((h=>h.map((u=>Math.round(u))))),kt=l=>l.itemSize===1?l.map((h=>Math.trunc(h))):l.map((h=>h.map((u=>Math.trunc(u))))),re=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize===1)return O.array.minMax(l.array);const h=new Array(l.itemSize).fill(Number.POSITIVE_INFINITY),u=new Array(l.itemSize).fill(Number.NEGATIVE_INFINITY);return l.forEach((i=>{i.forEach(((r,s)=>{r<h[s]&&(h[s]=r),r>u[s]&&(u[s]=r)}))})),[...h,...u]},se=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize===1)return O.array.min(l.array);const h=new Array(l.itemSize).fill(Number.POSITIVE_INFINITY);return l.forEach((u=>{u.forEach(((i,r)=>{i<h[r]&&(h[r]=i)}))})),h},ne=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize===1)return O.array.max(l.array);const h=new Array(l.itemSize).fill(Number.POSITIVE_INFINITY);return l.forEach((u=>{u.forEach(((i,r)=>{i>h[r]&&(h[r]=i)}))})),h},Ie=(l,h)=>{if(l===void 0)throw new Error("serie s1 is undefined");if(h===void 0)throw new Error("serie s2 is undefined");return l.itemSize===h.itemSize&&l.count===h.count&&(0,O.reduce)([l,h],((u,[i,r])=>u&&i===r),!0)},qe=(l,h,u=1e-7)=>{if(l===void 0)throw new Error("serie s1 is undefined");if(h===void 0)throw new Error("serie s2 is undefined");return l.itemSize===h.itemSize&&l.count===h.count&&(0,O.reduce)([l,h],((i,[r,s])=>i&&Math.abs(r-s)<u),!0)},k=l=>{const h=[];if(l.itemSize===1)l.forEach(((u,i)=>{Number.isNaN(u)&&h.push(i)}));else{const u=l.itemSize;l.forEach(((i,r)=>{for(let s=0;s<u;++s)if(Number.isNaN(i[s])){h.push(r);break}}))}return h},A=(l,h=!1)=>{if(l===void 0)throw new Error("series is undefined");const u=l.itemSize;if(l.dimension!==2||u!==3&&u!==4){if(l.dimension!==3||u!==6&&u!==9)throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${u}`);return u===9?l.map(((i,r)=>{const s=i[0]*(i[4]*i[8]-i[7]*i[5])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]);if(s===0){const f=`matrix at index${r} has a determinant = 0`;if(h===!0)throw new Error(f);return console.warn(f),[0,0,0,0,0,0,0,0,0]}const o=1/s,c=[];return c[0]=(i[4]*i[8]-i[7]*i[5])*o,c[1]=(i[2]*i[7]-i[1]*i[8])*o,c[2]=(i[1]*i[5]-i[2]*i[4])*o,c[3]=(i[5]*i[6]-i[3]*i[8])*o,c[4]=(i[0]*i[8]-i[2]*i[6])*o,c[5]=(i[3]*i[2]-i[0]*i[5])*o,c[6]=(i[3]*i[7]-i[6]*i[4])*o,c[7]=(i[6]*i[1]-i[0]*i[7])*o,c[8]=(i[0]*i[4]-i[3]*i[1])*o,c})):l.map(((i,r)=>{const s=i[0],o=i[1],c=i[2],f=o,y=i[3],S=i[4],q=c,m=S,t=i[5],e=t*y-m*S,n=m*c-t*o,a=S*o-y*c,d=s*e+f*n+q*a;if(d===0){const g=`matrix at index${r} has a determinant = 0`;if(h===!0)throw new Error(g);return console.warn(g),[0,0,0,0,0,0]}const p=1/d;return[e*p,n*p,a*p,(t*s-q*c)*p,(q*o-m*s)*p,(y*s-f*o)*p]}))}return l.map(((i,r)=>{const s=[0,0,0,0];u===4?(s[0]=i[0],s[1]=i[1],s[2]=i[2],s[3]=i[3]):(s[0]=i[0],s[1]=i[1],s[2]=i[1],s[3]=i[2]);const o=s[0]*s[3]-s[1]*s[2];if(o===0){const f=`matrix at index${r} has a determinant = 0`;if(h===!0)throw new Error(f);return console.warn(f),u===3?[0,0,0]:[0,0,0,0]}const c=1/o;return u===3?[s[3]*c,-s[1]*c,s[0]*c]:[s[3]*c,-s[1]*c,-s[2]*c,s[0]*c]}))},z=(l,h,u=!1)=>{if(l===void 0)throw new Error("s is undefined");if(h===void 0)throw new Error("rot is undefined");if(u){if(Array.isArray(h)){if(l.itemSize===1)return l.clone();if(l.itemSize===3){const i=st.transpose(h);return l.map((r=>st.multVec(i,r)))}return l.itemSize===9?l.map((i=>st.rotateInverse(st.unpack(i),h))):l.map((i=>st.pack(st.rotateInverse(st.unpack(i),h),!0)))}if(h.itemSize!==9)throw new Error("rot should have itemSize=9");return l.itemSize===1?l.clone():l.itemSize===3?wt(vt(h),l):wt(vt(h),wt(l,h))}if(Array.isArray(h))return l.itemSize===1?l.clone():l.itemSize===3?l.map((i=>st.multVec(h,i))):l.itemSize===9?l.map((i=>st.rotateForward(st.unpack(i),h))):l.map((i=>st.pack(st.rotateForward(st.unpack(i),h),!0)));if(h.itemSize!==9)throw new Error("rot should have itemSize=9");return l.itemSize===1?l.clone():l.itemSize===3?wt(h,l):wt(h,wt(l,vt(h)))},M=(l,h)=>{if(l===void 0)throw new Error("s is undefined");if(h===void 0)throw new Error("t is undefined");if(h.length!==l.itemSize)throw new Error(`t should be of length ${l.itemSize} (same as serie itemSize)`);return l.itemSize===1?l.map((u=>u*h[0])):l.map((u=>u.map(((i,r)=>i+h[r]))))},P=(l,h)=>{if(l===void 0)throw new Error("s is undefined");if(h===void 0)throw new Error("t is undefined");if(Array.isArray(h)){if(l.itemSize===1)return l.map((u=>u*h[0]));if(h.length!==l.itemSize)throw new Error(`t should be of length ${l.itemSize} (same as serie itemSize)`);return l.map((u=>u.map(((i,r)=>i*h[r]))))}return l.itemSize===1?l.map((u=>u*h)):l.map((u=>u.map((i=>i*h))))};function C(l){const h=[];l.forEach((r=>h.push(r)));let u,i=h.length;for(;i!=0;)u=Math.floor(Math.random()*i),i--,[h[i],h[u]]=[h[u],h[i]];return O.Serie.create({array:O.array.flatten(h),itemSize:l.itemSize,dimension:l.dimension})}function L(l){if(l===void 0)throw new Error("series is undefined");if(l.itemSize!==3&&l.itemSize!==4||l.dimension!==2){if(l.itemSize!==6&&l.itemSize!==9||l.dimension!==3)throw new Error("item size should be 3, 4, 6 or 9");{const h=u=>u.length===6?(0,O.symSquaredMatrix)(u):(0,O.squaredMatrix)(u);return l.map((u=>{const i=h(u);return i.at(0,0)*i.at(1,1)*i.at(2,2)-i.at(0,0)*i.at(1,2)*i.at(2,1)-i.at(0,1)*i.at(1,0)*i.at(2,2)+i.at(0,1)*i.at(1,2)*i.at(2,0)+i.at(0,2)*i.at(1,0)*i.at(2,1)-i.at(0,2)*i.at(1,1)*i.at(2,0)}))}}{const h=u=>u.length===3?(0,O.symSquaredMatrix)(u):(0,O.squaredMatrix)(u);return l.map((u=>{const i=h(u);return i.at(0,0)*i.at(1,1)-i.at(0,1)*i.at(1,0)}))}}const zt=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize!==6&&l.itemSize!==3)throw new Error("Series does not have itemSize = 3 or 6 (symmetric tensor [xx,xy,yy] or [xx,xy,xz,yy,yz,zz])");return l.map((h=>h.map((u=>-u))))},xt=l=>{if(l===void 0)throw new Error("series is undefined");const h=l.itemSize;if(h===1)return l.array.reduce(((i,r)=>i+r),0)/l.length;const u=new Array(h).fill(0);return l.forEach((i=>{for(let r=0;r<h;++r)u[r]+=i[r]/l.count})),u},Ot=(l,h)=>{if(l.length!==h.length)throw new Error("x and y must have the same length");if(l.itemSize!==1)throw new Error("x must have itemSize = 1");if(h.itemSize!==1)throw new Error("y must have itemSize = 1");const u=l.length,i=xt(l),r=xt(h);return ct(R(l,i),R(h,r)).array.reduce(((s,o)=>s+o/u),0)},ge=l=>Ot(l,l),Qt=(l,h)=>{if(l===void 0)throw new Error("s is undefined");if(h===void 0)throw new Error("w is undefined");if(h.count!==l.count)throw new Error(`count mismatch for s (${l.count}) and w (${h.count})`);if(h.itemSize!==1)throw new Error(`itemSize for w should be 1 (got ${h.itemSize})`);const u=h.array.reduce(((s,o)=>s+o),0),i=l.itemSize;if(i===1)return l.array.reduce(((s,o,c)=>s+o*h.array[c]),0)/u;const r=new Array(i).fill(0);return l.forEach(((s,o)=>{for(let c=0;c<i;++c)r[c]+=h.array[o]*s[c]})),r.map((s=>s/u))},Vt=(l,h)=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize!==1)throw new Error("quantile algorithm: itemSize must be 1");if(h<0)throw new Error("quantile must be >= 0");if(h>1)throw new Error("quantile must be <= 1");const u=(0,O.sort)(l).array,i=(u.length-1)*h,r=Math.floor(i),s=i-r;return u[r+1]!==void 0?u[r]+s*(u[r+1]-u[r]):u[r]},ye=l=>Vt(l,.25),Fe=l=>Vt(l,.5),Bt=l=>Vt(l,.75),we=l=>Vt(l,.75)-Vt(l,.25),Te=(l,h)=>{const u=ae(l,h);return(0,O.cut)(l,(i=>i<u.min||i>u.max))},oe=(l,h)=>{const u=ae(l,h);return(0,O.check)(l,(i=>i<u.min||i>u.max))},Qe=(l,h=1.5)=>{const u=ae(l,h);return(0,O.cut)(l,(i=>i>=u.min&&i<=u.max))},ae=(l,h)=>{const u=ye(l),i=Bt(l),r=i-u;return{min:u-h*r,max:i+h*r}},xe=l=>{if(l===void 0)throw new Error("series is undefined");if(l.itemSize!==1)throw new Error("quantile algorithm: itemSize must be 1");const h=xt(l),u=l.map((i=>(i-h)**2));return Math.sqrt(bt(u)/(l.length-1))},Pt=l=>{if(l===void 0)throw new Error("serie is undefined");if(l.itemSize!==1)throw new Error("serie must have itemSize = 1");return{count:l.count,mean:xt(l),std:xe(l),min:se(l),q25:ye(l),q50:Fe(l),q75:Bt(l),max:ne(l)}};function he(l,{size:h,nb:u,start:i,stop:r}){if(l.itemSize!==1)throw new Error("itemSize should be 1");if(h===void 0&&u===void 0)throw new Error("size or nb must be provided");const s=re(l);i===void 0&&(i=s[0]),r===void 0&&(r=s[1]),u!==void 0?h=(r-i)/u:u=Math.trunc(r-i)/h;const o=new Array(u).fill(0);return l.forEach((c=>{let f=Math.trunc((c-i)/h);if(f>=u&&(f=u-1),f<0||f>=u)throw new Error(`index for bin (${f}) out of bounds (0, ${u})`);o[f]++})),O.Serie.create({array:o,itemSize:1})}class Ve{names(h,u,i,r){if(r==="positions"||r==="indices")return[];const s=(0,O.nameOfSerie)(h,i);if(r===s&&i.itemSize===1)return[];if(u>1)return[];if(i.dimension===2)switch(i.itemSize){case 2:return ke.map((c=>r+c));case 3:return _e.map((c=>r+c));case 4:return Dt.map((c=>r+c))}else switch(i.itemSize){case 3:return Yt.map((c=>r+c));case 6:return ce.map((c=>r+c));case 9:return ue.map((c=>r+c))}const o=[];for(let c=0;c<u;++c)o.push(r+c);return o}serie(h,u,i){if(u>1)return;let r=i.substring(0,i.length-1),s=h.series[r];if(s){if(s.dimension===2){for(let o=0;o<ke.length;++o)if(i===r+ke[o])return(0,O.apply)(s,(c=>c[o]))}else for(let o=0;o<Yt.length;++o)if(i===r+Yt[o])return(0,O.apply)(s,(c=>c[o]))}if(r=i.substring(0,i.length-2),s=h.series[r],s)if(s.dimension===2){for(let o=0;o<_e.length;++o)if(i===r+_e[o])return(0,O.apply)(s,(c=>c[o]));for(let o=0;o<Dt.length;++o)if(i===r+Dt[o])return(0,O.apply)(s,(c=>c[o]))}else{for(let o=0;o<ce.length;++o)if(i===r+ce[o])return(0,O.apply)(s,(c=>c[o]));for(let o=0;o<ue.length;++o)if(i===r+ue[o])return(0,O.apply)(s,(c=>c[o]))}if(r=i.substring(0,i.length-1),s=h.series[r],s){for(let o=0;o<u;++o)if(i===r+o)return(0,O.apply)(s,(c=>c[o]))}}}const ke=["x","y"],_e=["xx","xy","yy"],Dt=["xx","xy","yx","yy"],Yt=["x","y","z"],ce=["xx","xy","xz","yy","yz","zz"],ue=["xx","xy","xz","yx","yy","yz","zx","zy","zz"];class Oe{constructor(h=["x","y","z"]){if(this.names_=h,h.length!==3)throw new Error("names must be an array of 3 strings (the dimension)")}names(h,u,i,r){return u!==1||r!=="positions"?[]:this.names_}serie(h,u,i){if(u===1){const r=h.series.positions;switch(i){case this.names_[0]:return(0,O.apply)(r,(s=>s[0]));case this.names_[1]:return(0,O.apply)(r,(s=>s[1]));case this.names_[2]:return(0,O.apply)(r,(s=>s[2]))}}}}class Be{names(h,u,i,r){return r==="positions"||r==="indices"?[]:(i.dimension!==2||i.itemSize===3&&u===1)&&(i.dimension!==3||i.itemSize===6&&u===1)?i.dimension===2?[r+"1",r+"2"]:[r+"1",r+"2",r+"3"]:[]}serie(h,u,i){if(u!==1)return;const r=i.substring(0,i.length-1),s=h.series[r],o=parseInt(i.charAt(i.length-1));if(s!==void 0){if(s.dimension===2){if(s.itemSize!==3||o<1||o>2)return}else if(s.itemSize!==6||o<1||o>3)return;return(0,O.apply)(J(s),(c=>c[o-1]))}}}class Pe{names(h,u,i,r){return r==="positions"||r==="indices"?[]:i.dimension===2?i.itemSize!==3||u!==2?[]:[r+"1",r+"2"]:i.itemSize!==6||u!==3?[]:[r+"1",r+"2",r+"3"]}serie(h,u,i){const r=i.substring(0,i.length-1);let s=parseInt(i.charAt(i.length-1));const o=h.series[r];if(o!==void 0){if(o.dimension===2)return u!==2||o===void 0||o.itemSize!==3||s<1||s>2?void 0:(s-=1,(0,O.apply)(D(o),(c=>[c[2*s],c[2*s+1]])));if(u===3&&o!==void 0&&o.itemSize===6&&!(s<1||s>3))return s-=1,(0,O.apply)(D(o),(c=>[c[3*s],c[3*s+1],c[3*s+2]]))}}}class Ze{names(h,u,i,r){return r==="positions"||r==="indices"||i.itemSize<=1||u!==1?[]:i.dimension===2&&i.itemSize===2||i.dimension===3&&i.itemSize===3?[r]:[]}serie(h,u,i){if(u!==1||i==="positions"||i==="indices")return;const r=h.series[i];return r===void 0||r.itemSize<=1?void 0:r.dimension===2&&r.itemSize===2||r.dimension===3&&r.itemSize===3?Tt(r):void 0}}class He{constructor(h="normals"){this.name=h}names(h,u,i,r){return u!==3?[]:(0,O.exists)(h,"positions")||(0,O.exists)(h,"indices")?[this.name]:[]}serie(h,u,i){if(i!==this.name)return;const r=h.series.positions,s=h.series.indices;if(!r||!s)return;const o=new Array(s.count).fill(0);let c=0;return s.forEach((f=>{const y=r.itemAt(f[0]),S=r.itemAt(f[1]),q=r.itemAt(f[2]),m=mt.cross(mt.create(y,S),mt.create(y,q));o[c++]=m[0],o[c++]=m[1],o[c++]=m[2]})),O.Serie.create({array:(0,O.createTyped)(Float32Array,o,!0),itemSize:3})}}class ti{constructor(h="valence"){this.name=h}names(h,u,i,r){return u!==1?[]:(0,O.exists)(h,"positions")||(0,O.exists)(h,"indices")?[this.name]:[]}serie(h,u,i){if(i!==this.name)return;const r=h.series.positions,s=h.series.indices;if(!r||!s)return;const o=new Array(r.count).fill(0);return s.forEach((c=>{o[c[0]]++,o[c[1]]++,o[c[2]]++})),O.Serie.create({array:(0,O.createTyped)(Int8Array,o,!0),itemSize:1})}}class $e{constructor(h="area"){this.name=h}names(h,u,i,r){return u!==1?[]:(0,O.exists)(h,"positions")||(0,O.exists)(h,"indices")?[this.name]:[]}serie(h,u,i){if(i!==this.name)return;const r=new He().serie(h,u,"normals");return r?Lt(Tt(r),2):void 0}}class Re{constructor(h,u){this.name=h,this.fringes=u}names(h,u,i,r){return u!==1?[]:[this.name]}serie(h,u,i){if(i!==this.name)return;const r=h.series[this.name];return r?(0,O.apply)(r,(s=>{return Math.abs(this.fringes*((o=s/this.fringes)-Math.floor(o)));var o})):void 0}}const Le=1e-5,ei=100,ii=Math.cos(Math.PI/4),ri=Math.sin(Math.PI/4);function de(l){const h=[],u=[],i=[],r=[],s=[];let o=0,c=0,f=0,y=0,S=0,q=0,m=0,t=0,e=0,n=0,a=0,d=0,p=0,g=0,_=0,x=0,w=0;if(l.length===3)w=2,i[0]=l[0],i[1]=l[1],i[2]=l[2];else if(l.length===4)w=2,i[0]=l[0],i[1]=l[1],i[2]=l[3];else if(l.length===6)w=3,i[0]=l[0],i[1]=l[1],i[2]=l[3],i[3]=l[2],i[4]=l[4],i[5]=l[5];else{if(l.length!==9)throw new Error(`matrix-array should be of size 2 (xx,xy,yy),
        4 (xx,xy,yx,yy), 6 (xx,xy,xz,yy,yz,zz) or 9 (xx,xy,xz,yx,yy,yz,zx,zy,zz).
        Got ${l.length}`);w=3,i[0]=l[0],i[1]=l[1],i[2]=l[4],i[3]=l[2],i[4]=l[5],i[5]=l[8]}const v=w*(w+1)/2;let b=0;for(let E=0;E<w;++E)for(let I=0;I<w;++I)r[b++]=E===I?1:0;b=1;let N=0;for(let E=1;E<=w;++E)for(let I=1;I<=E;++I)E!==I&&(e=i[b-1],N+=e*e),++b;if(N!==0){const E=N*Le;let I=N;for(;I>E&&o<ei;){++o,c=I/v;for(let T=1;T<w;++T)for(let B=T+1;B<=w;++B){const F=(T*T-T)/2,j=(B*B-B)/2,H=T+j,nt=i[H-1],it=nt*nt;if(it<c)continue;const Y=T+F,tt=B+j,dt=i[Y-1],V=i[tt-1],K=dt-V;K===0?(g=-Math.PI/4,_=ri,x=ii):(g=-Math.atan((nt+nt)/K)/2,_=Math.sin(g),x=Math.cos(g));const X=_*_,Q=x*x,ot=_*x;let lt=w*(T-1),et=w*(B-1);for(let W=1;W<=w;++W)W!==T&&W!==B&&(m=(W*W-W)/2,q=W<B?W+j:B+m,n=i[q-1],t=W<T?W+F:T+m,a=i[t-1],i[t-1]=a*x-n*_,i[q-1]=a*_+n*x),++lt,++et,d=r[lt-1],p=r[et-1],r[lt-1]=x*d-_*p,r[et-1]=_*d+x*p;g=nt*ot,g+=g,i[Y-1]=dt*Q+V*X-g,i[tt-1]=dt*X+V*Q+g,i[H-1]=0,I=Math.abs(I-it)}}}for(let E=0;E<w;++E)y=E+E*(E+1)/2,h[E]=i[y],s[E]=E;for(let E=0;E<w-1;++E){g=h[E],y=E;for(let I=E+1;I<w;++I)g<h[I]&&(y=I,g=h[I]);h[y]=h[E],h[E]=g,f=s[y],s[y]=s[E],s[E]=f}b=0;for(let E=0;E<w;++E){S=s[E]*w;for(let I=0;I<w;++I)u[b++]=r[S++]}return{values:h,vectors:u}}class si{constructor(){this.eigenValues=[],this.eigenVectors=[],console.warn("Deprecated class. Use instead eigen(mat: Array<number>")}compute(h){const u=de(h);return this.eigenValues=u.values,this.eigenVectors=u.vectors,u}vector(h){return console.assert(h>=0&&h<3),[this.eigenVectors[3*h],this.eigenVectors[3*h+1],this.eigenVectors[3*h+2]]}get vectors(){return this.eigenVectors}value(h){return console.assert(h>=0&&h<3),this.eigenValues[h]}get values(){return this.eigenValues}}const Nt=(l,h)=>l.reduce(((u,i,r)=>u+i*h[r]),0),jt=(l,h)=>l.reduce(((u,i,r)=>u+i*h[r]),0),De=(l,h)=>[h[0]-l[0],h[1]-l[1]],Kt=(l,h)=>[h[0]-l[0],h[1]-l[1],h[2]-l[2]];function Zt(l,h,u,i){const r=De(h,u),s=De(h,i),o=De(h,l),c=Nt(r,r),f=Nt(r,s),y=Nt(s,s),S=Nt(o,r),q=Nt(o,s),m=1/(c*y-f*f),t=(y*S-f*q)*m,e=(c*q-f*S)*m;return[1-t-e,t,e]}function ve(l,h,u,i){const r=Kt(h,u),s=Kt(h,i),o=Kt(h,l),c=jt(r,r),f=jt(r,s),y=jt(s,s),S=jt(o,r),q=jt(o,s),m=1/(c*y-f*f),t=(y*S-f*q)*m,e=(c*q-f*S)*m;return[1-t-e,t,e]}function Se(l,h,u,i,r){const s=m=>[m[0],m[1],m[2],1],o=s(h),c=s(u),f=s(i),y=s(r),S=s(l),q=_t(o,c,f,y);return[_t(S,c,f,y)/q,_t(o,S,f,y)/q,_t(o,c,S,y)/q,_t(o,c,f,S)/q]}function _t(l,h,u,i){return l[3]*h[2]*u[1]*i[0]-l[2]*h[3]*u[1]*i[0]-l[3]*h[1]*u[2]*i[0]+l[1]*h[3]*u[2]*i[0]+l[2]*h[1]*u[3]*i[0]-l[1]*h[2]*u[3]*i[0]-l[3]*h[2]*u[0]*i[1]+l[2]*h[3]*u[0]*i[1]+l[3]*h[0]*u[2]*i[1]-l[0]*h[3]*u[2]*i[1]-l[2]*h[0]*u[3]*i[1]+l[0]*h[2]*u[3]*i[1]+l[3]*h[1]*u[0]*i[2]-l[1]*h[3]*u[0]*i[2]-l[3]*h[0]*u[1]*i[2]+l[0]*h[3]*u[1]*i[2]+l[1]*h[0]*u[3]*i[2]-l[0]*h[1]*u[3]*i[2]-l[2]*h[1]*u[0]*i[3]+l[1]*h[2]*u[0]*i[3]+l[2]*h[0]*u[1]*i[3]-l[0]*h[2]*u[1]*i[3]-l[1]*h[0]*u[2]*i[3]+l[0]*h[1]*u[2]*i[3]}function je(l){let h=Number.POSITIVE_INFINITY;const u=l.length;for(let i=0;i<u;++i){const r=l[i];r<h&&(h=r)}return h}function Ge(l){let h=Number.NEGATIVE_INFINITY;const u=l.length;for(let i=0;i<u;++i){const r=l[i];r>h&&(h=r)}return h}function Ht(l){let h=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY;const i=l.length;for(let r=0;r<i;++r){const s=l[r];s<h&&(h=s),s>u&&(u=s)}return[h,u]}function Ye(l){const h=Ht(l);return l.map((u=>(u-h[0])/(h[1]-h[0])))}function St(l,h){return l.map((u=>u*h))}function yt(l){return l.map(((h,u)=>({value:h,i:u}))).filter((h=>Number.isNaN(h.value))).map((h=>h.i))}function Ke(l){const h=[];return l.forEach((u=>h.push(...u))),h}function Et(l,h,u,i,r){const s=1/(u-h);return i*(u-l)*s+r*(l-h)*s}function ze(l,h,u,i,r,s,o){const c=Et(l[0],h[0],u[0],i,s),f=Et(l[0],h[0],u[0],r,o);return Et(l[1],h[1],u[1],c,f)}function Ue(l,h,u,i,r,s,o,c,f,y,S){const q=Et(l[0],h[0],u[0],i,c),m=Et(l[0],h[0],u[0],s,y),t=Et(l[0],h[0],u[0],r,f),e=Et(l[0],h[0],u[0],o,S),n=Et(l[1],h[1],u[1],q,t),a=Et(l[1],h[1],u[1],m,e);return Et(l[2],h[2],u[2],n,a)}function Mt(l,h,u,i,r,s,o){const c=Zt(l,h,u,i);if(Array.isArray(r))return r.map(((S,q)=>S*c[0]+s[q]*c[1]+o[q]*c[2]));const f=s,y=o;return c[0]*r+c[1]*f+c[2]*y}function Ce(l,h,u,i,r,s,o){const c=ve(l,h,u,i);if(Array.isArray(r))return r.map(((S,q)=>S*c[0]+s[q]*c[1]+o[q]*c[2]));const f=s,y=o;return c[0]*r+c[1]*f+c[2]*y}function ni(l,h,u,i,r,s,o,c,f){const y=Se(l,h,u,i,r);if(Array.isArray(s))return s.map(((t,e)=>t*y[0]+o[e]*y[1]+c[e]*y[2]+f[e]*y[3]));const S=o,q=c,m=f;return y[0]*s+y[1]*S+y[2]*q+y[3]*m}var te,mt;function oi({attribute:l,topology:h,size:u=3,direction:i=te.INCREASING}){let r;if(l!==void 0)if(l.length!==0)if(h!==void 0)if(h.length!==0){if(Array.isArray(h[0]))r=h;else{if(r=[],h.length%u!=0)throw new Error(`Cannot meshInterpolate, topology (of size ${h.length}) is not divisable by ${u}`);for(let s=0;s<h.length;s+=u){const o=[];for(let c=0;c<u;++c)o.push(h[s+c]);r.push(o)}}switch(i){case te.INCREASING:return(function({from:s,topology:o}){if($t(o)[0]<0)throw new Error("Topology contains negatif indices");let c=s[0];c=Array.isArray(c)?c.slice().fill(0):0;const f=new Array(o.length).fill(c);return typeof c=="number"?o.forEach(((y,S)=>{f[S]=y.reduce(((q,m)=>q+s[m]))/y.length})):o.forEach(((y,S)=>{let q=c.slice();y.forEach((m=>{const t=s[m];q=q.map(((e,n)=>e+t[n]))})),f[S]=St(q,1/y.length)})),f})({from:l,topology:r});case te.DECREASING:return(function({from:s,topology:o}){const c=$t(o);if(c[0]<0)throw new Error("Topology contains negatif indices");let f,y=s[0],S=1;Array.isArray(y)?(y=y.slice().fill(0),S=y.length,f=new Array(c[1]+1).fill(void 0).map((m=>y.slice()))):(y=0,f=new Array(c[1]+1).fill(0));const q=new Array(f.length).fill(0);if(Array.isArray(y)){o.forEach(((m,t)=>{const e=s[t];m.forEach((n=>{const a=f[n];for(let d=0;d<S;++d)a[d]+=e[d];q[n]++}))}));for(let m=0;m<f.length;++m)for(let t=0;t<S;++t)f[m][t]/=q[m]}else{const m=f;o.forEach(((t,e)=>{const n=s[e];t.forEach((a=>{m[a]+=n,q[a]++}))}));for(let t=0;t<f.length;++t)m[t]/=q[t]}return f})({from:l,topology:r})}}else console.warn("Cannot meshInterpolate, topology is empty");else console.warn("Cannot meshInterpolate, attribute is topology");else console.warn("Cannot meshInterpolate, attribute is empty");else console.warn("Cannot meshInterpolate, attribute is undefined")}function $t(l){const h=[1/0,-1/0];return l.forEach((u=>{const i=Ht(u);h[0]=Math.min(h[0],i[0]),h[1]=Math.max(h[1],i[1])})),h}(function(l){l[l.INCREASING=0]="INCREASING",l[l.DECREASING=1]="DECREASING"})(te||(te={}));class ht{constructor(h){this.m_=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],h!==void 0&&this.add(h)}reset(){this.m_=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]}get min(){return this.m_[0]}get max(){return this.m_[1]}get length(){return this.m_[1]-this.m_[0]}get value(){return this.m_}normalize(h){return(h-this.min)/(this.max-this.min)}add(h){if(Array.isArray(h))h.forEach((u=>{u<this.m_[0]&&(this.m_[0]=u),u>this.m_[1]&&(this.m_[1]=u)}));else{const u=h;u<this.m_[0]&&(this.m_[0]=u),u>this.m_[1]&&(this.m_[1]=u)}return this}}(function(l){l.create=(h,u)=>u.map(((i,r)=>i-h[r])),l.norm2=h=>h.reduce(((u,i)=>u+i**2),0),l.norm=h=>Math.sqrt(l.norm2(h)),l.add=(h,u)=>h.map(((i,r)=>i+u[r])),l.sub=(h,u)=>h.map(((i,r)=>i-u[r])),l.scale=(h,u)=>h.map((i=>i*u)),l.setCoord=(h,u,i)=>h[u]=i,l.set=(h,u)=>u.forEach(((i,r)=>h[r]=u[r])),l.dot=(h,u)=>h.reduce(((i,r,s)=>i+r*u[s]),0),l.cross=(h,u)=>[h[1]*u[2]-h[2]*u[1],h[2]*u[0]-h[0]*u[2],h[0]*u[1]-h[1]*u[0]],l.normalize=h=>{const u=l.norm(h);return h.map((i=>i/u))},l.clone=h=>[...h]})(mt||(mt={}));const We=(l,h,u)=>{l[h][0]=u[0],l[h][1]=u[1],l[h][2]=u[2]};class It{constructor(){this.q=[0,0,0,1]}static fromAxisAngle(h,u){const i=new It;return i.setAxisAngle(h,u),i}static fromProd(h,u){const i=new It;return i.q[0]=h.q[3]*u.q[0]+u.q[3]*h.q[0]+h.q[1]*u.q[2]-h.q[2]*u.q[1],i.q[1]=h.q[3]*u.q[1]+u.q[3]*h.q[1]+h.q[2]*u.q[0]-h.q[0]*u.q[2],i.q[2]=h.q[3]*u.q[2]+u.q[3]*h.q[2]+h.q[0]*u.q[1]-h.q[1]*u.q[0],i.q[3]=h.q[3]*u.q[3]-u.q[0]*h.q[0]-h.q[1]*u.q[1]-h.q[2]*u.q[2],i}static fromBase(h,u,i){const r=new It;return r.setFromBase(h,u,i),r}static fromRotationMatrix(h){const u=new It;return u.setFromRotationMatrix(h),u}static fromTo(h,u){const i=new It;return i.setFromTo(h,u),i}get data(){return this.q}get axis(){const h=[this.q[0],this.q[1],this.q[2]],u=mt.norm(h);return u>1e-8&&mt.scale(h,1/u),Math.acos(this.q[3])<=Math.PI/2?h:mt.scale(h,-1)}get angle(){const h=2*Math.acos(this.q[3]);return h<=Math.PI?h:2*Math.PI-h}equals(h){for(let u=0;u<4;++u)if(this.q[u]!==h.q[u])return!1;return!0}notEquals(h){return!this.equals(h)}prod(h){const u=It.fromProd(this,h);return this.setFrom(u)}inverse(){const h=new It;for(let u=0;u<3;++u)h.q[u]=-this.q[u];return h.q[3]=this.q[3],h}invert(){return this.q[0]*=-1,this.q[1]*=-1,this.q[2]*=-1,this}negate(){return this.invert(),this.q[3]*=-1,this}normalize(){const h=this.q,u=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]+h[3]*h[3]);for(let i=0;i<4;++i)h[i]/=u;return u}dot(h,u){const i=h.q,r=u.q;return i[0]*r[0]+i[1]*r[1]+i[2]*r[2]+i[3]*r[3]}iRotate(h){const u=this.q,i=2*u[0]*u[0],r=2*u[1]*u[1],s=2*u[2]*u[2],o=2*u[0]*u[1],c=2*u[0]*u[2],f=2*u[0]*u[3],y=2*u[1]*u[2],S=2*u[1]*u[3],q=2*u[2]*u[3];return[(1-r-s)*h[0]+(o+q)*h[1]+(c-S)*h[2],(o-q)*h[0]+(1-s-i)*h[1]+(y+f)*h[2],(c+S)*h[0]+(y-f)*h[1]+(1-r-i)*h[2]]}rotate(h){const u=this.q,i=2*u[0]*u[0],r=2*u[1]*u[1],s=2*u[2]*u[2],o=2*u[0]*u[1],c=2*u[0]*u[2],f=2*u[0]*u[3],y=2*u[1]*u[2],S=2*u[1]*u[3],q=2*u[2]*u[3];return[(1-r-s)*h[0]+(o-q)*h[1]+(c+S)*h[2],(o+q)*h[0]+(1-s-i)*h[1]+(y-f)*h[2],(c-S)*h[0]+(y+f)*h[1]+(1-r-i)*h[2]]}toMatrix(){this.normalize();const h=this.q,u=[[0,0,0],[0,0,0],[0,0,0]],i=h[0],r=h[1],s=h[2],o=h[3];return u[0][0]=2*(i*i+r*r)-1,u[0][1]=2*(r*s-i*o),u[0][2]=2*(r*o+i*s),u[1][0]=2*(r*s+i*o),u[1][1]=2*(i*i+s*s)-1,u[1][2]=2*(s*o-i*r),u[2][0]=2*(r*o-i*s),u[2][1]=2*(s*o+i*r),u[2][2]=2*(i*i+o*o)-1,u}setFrom(h){for(let u=0;u<4;++u)this.q[u]=h.q[u];return this}setAxisAngle(h,u){const i=mt.norm(h);if(i<1e-9)this.q[0]=0,this.q[1]=0,this.q[2]=0,this.q[3]=1;else{const r=Math.sin(u/2);this.q[0]=r*h[0]/i,this.q[1]=r*h[1]/i,this.q[2]=r*h[2]/i,this.q[3]=Math.cos(u/2)}return this}setFromTo(h,u){const r=mt.norm2(h),s=mt.norm2(u),o=mt.cross(h,u),c=mt.norm2(o),f=this.q,y=mt.dot(h,u)/Math.sqrt(r*s);if(y<0&&1-Math.abs(y)<1e-10)return f[0]=f[1]=f[2]=0,f[3]=1,this;if(r<1e-10||s<1e-10||c<1e-10)f[0]=f[1]=f[2]=0,f[3]=1;else{let S=Math.asin(Math.sqrt(c/r/s));mt.dot(h,u)<0&&(S=Math.PI-S),this.setAxisAngle(o,S)}return this}setFromRotationMatrix(h){let u=2;if(h[0][0]>h[1][1]?h[0][0]>h[2][2]&&(u=0):h[1][1]>h[2][2]&&(u=1),h[0][0]+h[1][1]+h[2][2]>h[u][u])this.q[3]=Math.sqrt(h[0][0]+h[1][1]+h[2][2]+1)/2,this.q[0]=(h[2][1]-h[1][2])/(4*this.q[3]),this.q[1]=(h[0][2]-h[2][0])/(4*this.q[3]),this.q[2]=(h[1][0]-h[0][1])/(4*this.q[3]);else{const i=(u+1)%3,r=(u+2)%3;this.q[u]=Math.sqrt(h[u][u]-h[i][i]-h[r][r]+1)/2,this.q[i]=(h[u][i]+h[i][u])/(4*this.q[u]),this.q[r]=(h[u][r]+h[r][u])/(4*this.q[u]),this.q[3]=(h[r][i]-h[i][r])/(4*this.q[u])}return this}setFromBase(h,u,i){const r=[[0,0,0],[0,0,0],[0,0,0]],s=mt.norm(h),o=mt.norm(u),c=mt.norm(i);for(let f=0;f<3;++f)We(r,f,[h[f]/s,u[f]/o,i[f]/c]);return this.setFromRotationMatrix(r)}}function ai(l,h,u){const i=mt.norm(l),r=[0,0,0,1];if(i>1e-9){const e=Math.sin(.5*h)/i;r[0]=e*l[0],r[1]=e*l[1],r[2]=e*l[2],r[3]=Math.cos(.5*h)}const s=2*r[0]**2,o=2*r[1]**2,c=2*r[2]**2,f=2*r[0]*r[1],y=2*r[0]*r[2],S=2*r[0]*r[3],q=2*r[1]*r[2],m=2*r[1]*r[3],t=2*r[2]*r[3];return[(1-o-c)*u[0]+(f-t)*u[1]+(y+m)*u[2],(f+t)*u[0]+(1-c-s)*u[1]+(q-S)*u[2],(y-m)*u[0]+(q+S)*u[1]+(1-o-s)*u[2]]}function Xe(l,h){if(Array.isArray(l))return It.fromAxisAngle(l,h).toMatrix();let u=2;l==="x"||l==="X"?u=0:l!=="y"&&l!=="Y"||(u=1);const i=[[0,0,0],[0,0,0],[0,0,0]],r=Math.cos(h*Math.PI/180),s=Math.sin(h*Math.PI/180);return u===2?(i[0][0]=r,i[0][1]=-s,i[1][0]=s,i[1][1]=r,i[2][2]=1):u===0?(i[0][0]=1,i[1][1]=r,i[1][2]=-s,i[2][1]=s,i[2][2]=r):(i[0][0]=r,i[0][2]=s,i[2][0]=-s,i[1][1]=1,i[2][2]=r),i}var st;(function(l){function h(s){return s.length===6?[[s[0],s[1],s[2]],[s[1],s[3],s[4]],[s[2],s[4],s[5]]]:[[s[0],s[1],s[2]],[s[3],s[4],s[5]],[s[6],s[7],s[8]]]}function u(s,o){const c=[[0,0,0],[0,0,0],[0,0,0]];return c[0][0]=s[0][0]*o[0][0]+s[0][1]*o[1][0]+s[0][2]*o[2][0],c[0][1]=s[0][0]*o[0][1]+s[0][1]*o[1][1]+s[0][2]*o[2][1],c[0][2]=s[0][0]*o[0][2]+s[0][1]*o[1][2]+s[0][2]*o[2][2],c[1][0]=s[1][0]*o[0][0]+s[1][1]*o[1][0]+s[1][2]*o[2][0],c[1][1]=s[1][0]*o[0][1]+s[1][1]*o[1][1]+s[1][2]*o[2][1],c[1][2]=s[1][0]*o[0][2]+s[1][1]*o[1][2]+s[1][2]*o[2][2],c[2][0]=s[2][0]*o[0][0]+s[2][1]*o[1][0]+s[2][2]*o[2][0],c[2][1]=s[2][0]*o[0][1]+s[2][1]*o[1][1]+s[2][2]*o[2][1],c[2][2]=s[2][0]*o[0][2]+s[2][1]*o[1][2]+s[2][2]*o[2][2],c}function i(s){return[[s[0][0],s[1][0],s[2][0]],[s[0][1],s[1][1],s[2][1]],[s[0][2],s[1][2],s[2][2]]]}function r(s,o){return u(o,u(s,i(o)))}l.unpack=h,l.pack=function(s,o=!0){return o?[s[0][0],s[0][1],s[0][2],s[1][1],s[1][2],s[2][2]]:[s[0][0],s[0][1],s[0][2],s[1][0],s[1][1],s[1][2],s[2][0],s[2][1],s[2][2]]},l.det=function(s){return s[0][0]*s[1][1]*s[2][2]-s[0][0]*s[1][2]*s[2][1]-s[0][1]*s[1][0]*s[2][2]+s[0][1]*s[1][2]*s[2][0]+s[0][2]*s[1][0]*s[2][1]-s[0][2]*s[1][1]*s[2][0]},l.multMat=u,l.multVec=function(s,o){const c=o[0],f=o[1],y=o[2];return[s[0][0]*c+s[0][1]*f+s[0][2]*y,s[1][0]*c+s[1][1]*f+s[1][2]*y,s[2][0]*c+s[2][1]*f+s[2][2]*y]},l.multTVec=function(s,o){const c=o[0],f=o[1],y=o[2];return[s[0][0]*c+s[1][0]*f+s[2][0]*y,s[0][1]*c+s[1][1]*f+s[2][1]*y,s[0][2]*c+s[1][2]*f+s[2][2]*y]},l.inv=function(s,o){const c=s[0][0],f=s[0][1],y=s[0][2],S=s[1][0],q=s[1][1],m=s[1][2],t=s[2][0],e=s[2][1],n=s[2][2],a=n*q-m*e,d=m*t-n*S,p=e*S-q*t,g=c*a+f*d+y*p;if(g===0){const x="Matrix3: .getInverse() can't invert matrix, determinant is 0";if(o===!0)throw new Error(x);return console.warn(x),this.identity()}const _=1/g;return[[a*_,(y*e-n*f)*_,(m*f-y*q)*_],[d*_,(n*c-y*t)*_,(y*S-m*c)*_],[p*_,(f*t-e*c)*_,(q*c-f*S)*_]]},l.transpose=i,l.transposeSelf=function(s){let o;return o=s[0][1],s[0][1]=s[1][0],s[1][0]=o,o=s[0][2],s[0][2]=s[2][0],s[2][0]=o,o=s[1][2],s[1][2]=s[2][1],s[2][1]=o,this},l.rotate=function(s,o,c){return r(s,Xe(c,o))},l.rotateInverse=function(s,o){return u(i(o),u(s,o))},l.rotateForward=r,l.makeRotationX=function(s){const o=Math.cos(s*Math.PI/180),c=Math.sin(s*Math.PI/180);return h([1,0,0,0,o,-c,0,c,o])},l.makeRotationY=function(s){const o=Math.cos(s*Math.PI/180),c=Math.sin(s*Math.PI/180);return h([o,0,c,0,1,0,-c,0,o])},l.makeRotationZ=function(s){const o=Math.cos(s*Math.PI/180),c=Math.sin(s*Math.PI/180);return h([o,-c,0,c,o,0,0,0,1])}})(st||(st={}));const hi=(l,h=!1)=>{let u=(function(){pt==0&&(ci||(function(r){qt[0]=r;for(let s=1;624>s;++s)qt[s]=1812433253*(qt[s-1]^qt[s]>>30)+s&4294967295})(+new Date),(function(){for(let r=0;624>r;++r){const s=2147483648&qt[r]|2147483647&qt[(r+1)%624];qt[r]=qt[(r+397)%624]^s>>1,s%2==1&&(qt[r]^=2567483615)}})());let i=qt[pt];return i^=i>>11,i^=i<<7&2636928640,i^=i<<15&4022730752,i^=i>>18,pt=(pt+1)%624,i/2147483648})();return l!=null&&(u*=l),h?~~u:u},qt=[];let pt=0;const ci=!1;function Ft(l,{x:h=0,y:u=0,z:i=0,lx:r,Lx:s,ly:o,Ly:c,nx:f,ny:y,name:S}){const q=s/(f-1),m=c/(y-1),t=l.series.positions,e=l.series[S];if(t===void 0)throw new Error("positions is undefined");if(e===void 0)throw new Error(`attribute named ${S} is undefined`);const n=new Ee(r,o),a=[],d=[];for(let p=0;p<f;++p){n.x=h+p*q;for(let g=0;g<y;++g)n.y=u+g*m,d.push(n.x,n.y,i),a.push(n.density(t,e))}return{nx:f,ny:y,positions:O.Serie.create({array:d,itemSize:3}),solution:O.Serie.create({array:a,itemSize:e.itemSize})}}class Ee{constructor(h,u){this.w=h,this.h=u,this.x=0,this.y=0}contains(h){return h[0]>=this.x&&h[1]>=this.y&&h[0]<=this.x+this.w&&h[1]<=this.y+this.h}density(h,u){let i,r=0;return i=u.itemSize===1?0:new Array(u.itemSize).fill(0),(0,O.forEach)([h,u],(([s,o])=>{if(this.contains(s))if(r++,u.itemSize===1)i+=o;else for(let c=0;c<u.itemSize;++c)i[c]+=o[c]})),u.itemSize===1?r===0?0:i/r:r===0?i:i.map((s=>s/r))}}function ui(l,h=100){let u=[],i=0;for(let s=0;s<h;++s)i+=l(s/(h-1)),u.push(i);u=u.map((s=>s/i));const r=1/h;return s=>{if(s<u[0])return s/u[0]*r;const o=di(u,s);return(o+(s-u[o-1])/(u[o]-u[o-1]))*r}}const di=(l,h)=>{let u=0,i=l.length;for(;u<i;){const r=Math.floor((u+i)/2);l[r]<h?u=r+1:i=r}return u}})(),ft})()))})(fi)),fi.exports}Ai();var mi={exports:{}},pi={exports:{}},bi=pi.exports,xi;function Ni(){return xi||(xi=1,(function(le,Ae){(function(At,gt){le.exports=gt(gi())})(typeof self<"u"?self:bi,(At=>(()=>{var gt={595:J=>{J.exports=At}},ut={};function Z(J){var D=ut[J];if(D!==void 0)return D.exports;var U=ut[J]={exports:{}};return gt[J](U,U.exports,Z),U.exports}Z.d=(J,D)=>{for(var U in D)Z.o(D,U)&&!Z.o(J,U)&&Object.defineProperty(J,U,{enumerable:!0,get:D[U]})},Z.o=(J,D)=>Object.prototype.hasOwnProperty.call(J,D),Z.r=J=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(J,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(J,"__esModule",{value:!0})};var ft={};return(()=>{Z.r(ft),Z.d(ft,{AreaDecomposer:()=>ei,ComponentDecomposer:()=>Dt,Eigen:()=>De,EigenValuesDecomposer:()=>He,EigenVectorsDecomposer:()=>ti,Fringes:()=>ii,IQR:()=>Qe,InterpolateDirection:()=>$t,MinMax:()=>ai,NormalsDecomposer:()=>Re,PositionDecomposer:()=>Ze,Quaternion:()=>st,ValenceDecomposer:()=>Le,VectorNormDecomposer:()=>$e,abs:()=>Wt,add:()=>U,addNumber:()=>at,areas:()=>Ot,barycenters:()=>ge,barycentric2:()=>_t,barycentric3:()=>je,barycentric4:()=>Ge,biLerp:()=>Ce,bins:()=>_e,closeTo:()=>qe,covariance:()=>Vt,cross:()=>Gt,dectectNan:()=>ze,describe:()=>ke,determinant:()=>L,div:()=>Lt,dot:()=>Xt,eigen:()=>jt,eigenValue:()=>J,eigenVector:()=>D,equals:()=>Ie,flatten:()=>Ue,getNaN:()=>k,getRotationAxis:()=>qt,inv:()=>A,inverseCDF:()=>h,invert:()=>Ne,isOutliers:()=>xe,lerp:()=>Mt,mat:()=>pt,max:()=>ne,maxArray:()=>St,mean:()=>Qt,meshInterpolate:()=>We,min:()=>se,minArray:()=>Ye,minMax:()=>re,minMaxArray:()=>yt,movingAverage:()=>di,mult:()=>ct,multMat:()=>wt,negate:()=>be,norm:()=>Tt,norm2:()=>Ut,normalize:()=>ee,normalizeArray:()=>Ke,normals:()=>xt,notOutliers:()=>Pt,outliers:()=>ae,q25:()=>we,q50:()=>Te,q75:()=>oe,quantile:()=>Bt,rand:()=>pe,randomMT:()=>ci,rotate:()=>z,rotateAxis:()=>hi,round:()=>ie,scale:()=>P,scaleArray:()=>Et,shuffle:()=>C,square:()=>me,std:()=>Ve,sub:()=>R,sum:()=>bt,switchConvention:()=>zt,tagNaN:()=>Me,tetraLerp:()=>oi,trace:()=>fe,translate:()=>M,transpose:()=>vt,triLerp:()=>ni,triangleLerp2D:()=>te,triangleLerp3D:()=>mt,trunc:()=>kt,unitInterval:()=>Jt,variance:()=>ye,vec:()=>ht,weightedMean:()=>Fe,weightedSum:()=>Ct});const J=i=>{if(i===void 0)throw new Error("series is undefined");const r=i.dimension;if((i.dimension!==2||i.itemSize!==3&&i.itemSize!==4)&&(i.dimension!==3||i.itemSize!==6&&i.itemSize!==9))throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${i.itemSize}`);const s=i.image(i.count,r),o=i.count;let c=0;for(let f=0;f<o;++f){const y=jt(i.itemAt(f));for(let S=0;S<r;++S)s.array[c++]=y.values[S]}return s},D=i=>{if(i===void 0)throw new Error("series is undefined");const r=i.dimension;if((i.dimension!==2||i.itemSize!==3&&i.itemSize!==4)&&(i.dimension!==3||i.itemSize!==6&&i.itemSize!==9))throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${i.itemSize}`);const s=i.image(i.count,r**2),o=i.count;let c=0;for(let f=0;f<o;++f)jt(i.itemAt(f)).vectors.forEach((y=>s.array[c++]=y));return s},U=i=>{if(i.length<=1)throw new Error("nb series should be greater than 1");const r=i[0].clone(!0);return i.forEach((s=>{if(s.length!==r.length)throw new Error(`size mistmatch. Cannot add 2 Series of different sizes (${s.length} != ${r.length})`);s.array.forEach(((o,c)=>r.array[c]+=o))})),r},at=(i,r)=>{const s=i.clone(!1);return r===0||s.array.forEach(((o,c)=>s.array[c]+=r)),s},R=(i,...r)=>{if(i===void 0)throw new Error("serie s is undefined");if(!r)throw new Error("cannot subtract undefined to s");const s=i.clone();return r&&r.forEach((o=>{if(typeof o=="number")s.array.forEach(((c,f)=>s.array[f]-=o));else{if(o.length!==i.length)throw new Error(`size mistmatch. Cannot add 2 Series of different sizes (${o.length} != ${i.length})`);o.array.forEach(((c,f)=>s.array[f]-=c))}})),s},ct=(i,...r)=>{if(i===void 0)return;if(!r)throw new Error("cannot multiply undefined to s");const s=i.clone();return r.forEach((o=>{if(typeof o=="number")s.array.forEach(((c,f)=>s.array[f]*=o));else{if(o.length!==i.length)throw new Error(`size mistmatch. Cannot multiply 2 Series of different sizes (${o.length} != ${i.length})`);o.array.forEach(((c,f)=>s.array[f]*=c))}})),s};var O=Z(595);const wt=(i,r)=>{if(i===void 0)throw new Error("s1 is undefined");if(r===void 0)throw new Error("s2 is undefined");if(typeof r=="number")return ct(i,r);if(r.itemSize===1)return i.map(((s,o)=>s*r.itemAt(o)));if(i.itemSize===1){if(r.itemSize!==1)throw new Error("s2 should have itemSize=1 (same as s1)");return i.map(((s,o)=>s*r.itemAt(o)))}if(i.itemSize===3){if(r.itemSize===3)return i.map(((s,o)=>{const c=r.itemAt(o);return s[0]*c[0]+s[1]*c[1]+s[2]*c[2]}));throw new Error("since s1 has itemSize=3, s2 should have itemSize=1 or 3")}if(i.itemSize===6||i.itemSize===9){if(r.itemSize===3)return i.map(((s,o)=>{const c=i.itemSize===6?(0,O.symSquaredMatrix)(s):(0,O.squaredMatrix)(s),f=new O.Vector(r.itemAt(o));return c.multVec(f).array}));if(r.itemSize===6||r.itemSize===9)return i.map(((s,o)=>{const c=i.itemSize===6?(0,O.symSquaredMatrix)(s):(0,O.squaredMatrix)(s),f=r.itemSize===6?(0,O.symSquaredMatrix)(r.itemAt(o)):(0,O.squaredMatrix)(r.itemAt(o));return c.multMat(f).array}))}throw new Error("Cannot multMat")},Lt=(i,...r)=>{if(i===void 0)return;if(!r)throw new Error("cannot divide undefined to s");const s=i.clone();return r&&r.forEach((o=>{if(typeof o=="number")s.array.forEach(((c,f)=>s.array[f]/=o));else{if(o.length!==i.length)throw new Error(`size mistmatch. Cannot divide 2 Series of different sizes (${o.length} != ${i.length})`);o.array.forEach(((c,f)=>s.array[f]/=c))}})),s};function fe(i){if(i===void 0)throw new Error("series is undefined");if(i.itemSize!==1&&i.itemSize!==3&&i.itemSize!==4&&i.itemSize!==6&&i.itemSize!==9)throw new Error("item size should be 1, 3, 4, 6 or 9");if(i.itemSize===1)return i.clone();const r=i.itemSize,s=i.image(i.count,1);for(let o=0;o<i.count;++o){const c=i.itemAt(o);s.array[o]=r===3?c[0]+c[2]:r===4?c[0]+c[3]:r===6?c[0]+c[3]+c[5]:c[0]+c[4]+c[8]}return s}const Tt=i=>Ut(i).map((r=>Math.sqrt(r))),Ut=i=>{if(i===void 0)throw new Error("series is undefined");const r=i.image(i.count,1);if(i.itemSize===1)return r;for(let s=0;s<i.count;++s){const o=i.itemAt(s);r.array[s]=o.reduce(((c,f)=>c+f**2),0)}return r},vt=i=>{if(i===void 0)return;if(i.itemSize!==9)throw new Error("items size should be 9 only (for now)");const r=i.clone(),s=r.array;let o=0;return i.forEach((c=>{s[o++]=c[0],s[o++]=c[3],s[o++]=c[6],s[o++]=c[1],s[o++]=c[4],s[o++]=c[7],s[o++]=c[2],s[o++]=c[5],s[o++]=c[8]})),r},me=i=>{if(i===void 0)throw new Error("series is undefined");return O.Serie.create({array:i.array.map((r=>r**2)),itemSize:i.itemSize,dimension:i.dimension})},Wt=i=>{if(i===void 0)throw new Error("series is undefined");return O.Serie.create({array:i.array.map((r=>Math.abs(r))),itemSize:i.itemSize,dimension:i.dimension})},Xt=(i,r)=>{if(i===void 0)throw new Error("serie a is undefined");if(r===void 0)throw new Error("serie or Vector b is undefined");return O.Serie.isSerie(r)===!0?(0,O.map)([i,r],(([s,o])=>(0,O.vector)(s).dot((0,O.vector)(o)))):(0,O.map)(i,(s=>(0,O.vector)(s).dot((0,O.vector)(r))))},Gt=(i,r)=>{if(i===void 0)throw new Error("serie A is undefined");if(r===void 0)throw new Error("serie B is undefined");if(i.itemSize!==3)throw new Error("cross only supports itemSize=3");if(r.itemSize!==3)throw new Error("cross only supports itemSize=3");return i.map(((s,o)=>{const c=r.itemAt(o);return[s[1]*c[2]-s[2]*c[1],s[2]*c[0]-s[0]*c[2],s[0]*c[1]-s[1]*c[0]]}))},ee=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize===1){const r=O.array.minMax(i.array),s=r[0],o=1/(r[1]-s);return i.map((c=>o*(c-s)))}return i.map((r=>{const s=1/Math.sqrt(r.reduce(((o,c)=>o+c*c),0));return r.map((o=>o*s))}))},Jt=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize===1){const r=O.array.minMax(i.array),s=r[0],o=1/(r[1]-s);return i.map((c=>o*(c-s)))}return i.map((r=>{const s=O.array.minMax(r),o=s[0],c=1/(s[1]-o);return r.map((f=>c*(f-o)))}))},be=i=>{if(i===void 0)throw new Error("series is undefined");return O.Serie.create({array:i.array.map((r=>-r)),itemSize:i.itemSize,dimension:i.dimension})},Ne=i=>{if(i===void 0)throw new Error("series is undefined");return O.Serie.create({array:i.array.map((r=>1/r)),itemSize:i.itemSize,dimension:i.dimension})},Ct=(i,r)=>{if(r.length!==i.length)throw new Error(`data length (${i.length}) should be equal to alpha length (${r.length})`);return U(i.map(((s,o)=>ct(s,r[o]))))},bt=i=>{if(i.itemSize===1){let s=0;return i.forEach((o=>s+=o)),s}const r=new Array(i.itemSize).fill(0);return i.forEach((s=>s.forEach(((o,c)=>r[c]+=o)))),r},Me=(i,r)=>i.itemSize===1?i.map(((s,o)=>r(s,o,i)?Number.NaN:s)):i.map(((s,o)=>r(s,o,i)?new Array(i.itemSize).fill(Number.NaN):s)),pe=(i,r=0,s=1)=>{const o=s-r;return i.itemSize===1?i.map((()=>r+o*Math.random())):i.map((()=>new Array(i.itemSize).fill(0).map((()=>r+o*Math.random()))))},ie=i=>i.itemSize===1?i.map((r=>Math.round(r))):i.map((r=>r.map((s=>Math.round(s))))),kt=i=>i.itemSize===1?i.map((r=>Math.trunc(r))):i.map((r=>r.map((s=>Math.trunc(s))))),re=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize===1)return O.array.minMax(i.array);const r=new Array(i.itemSize).fill(Number.POSITIVE_INFINITY),s=new Array(i.itemSize).fill(Number.NEGATIVE_INFINITY);return i.forEach((o=>{o.forEach(((c,f)=>{c<r[f]&&(r[f]=c),c>s[f]&&(s[f]=c)}))})),[...r,...s]},se=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize===1)return O.array.min(i.array);const r=new Array(i.itemSize).fill(Number.POSITIVE_INFINITY);return i.forEach((s=>{s.forEach(((o,c)=>{o<r[c]&&(r[c]=o)}))})),r},ne=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize===1)return O.array.max(i.array);const r=new Array(i.itemSize).fill(Number.POSITIVE_INFINITY);return i.forEach((s=>{s.forEach(((o,c)=>{o>r[c]&&(r[c]=o)}))})),r},Ie=(i,r)=>{if(i===void 0)throw new Error("serie s1 is undefined");if(r===void 0)throw new Error("serie s2 is undefined");return i.itemSize===r.itemSize&&i.count===r.count&&(0,O.reduce)([i,r],((s,[o,c])=>s&&o===c),!0)},qe=(i,r,s=1e-7)=>{if(i===void 0)throw new Error("serie s1 is undefined");if(r===void 0)throw new Error("serie s2 is undefined");return i.itemSize===r.itemSize&&i.count===r.count&&(0,O.reduce)([i,r],((o,[c,f])=>o&&Math.abs(c-f)<s),!0)},k=i=>{const r=[];if(i.itemSize===1)i.forEach(((s,o)=>{Number.isNaN(s)&&r.push(o)}));else{const s=i.itemSize;i.forEach(((o,c)=>{for(let f=0;f<s;++f)if(Number.isNaN(o[f])){r.push(c);break}}))}return r},A=(i,r=!1)=>{if(i===void 0)throw new Error("series is undefined");const s=i.itemSize;if(i.dimension!==2||s!==3&&s!==4){if(i.dimension!==3||s!==6&&s!==9)throw new Error(`Series does not have itemSize = 3, 4, 6 or 9 ([xx,xy,yy], [xx,xy,xz,yy,yz,zz], [xx, xy, yx, yy] or [xx,xy,xz,yx,yy,yz,zx,zy,zz]). Got ${s}`);return s===9?i.map(((o,c)=>{const f=o[0]*(o[4]*o[8]-o[7]*o[5])-o[1]*(o[3]*o[8]-o[5]*o[6])+o[2]*(o[3]*o[7]-o[4]*o[6]);if(f===0){const q=`matrix at index${c} has a determinant = 0`;if(r===!0)throw new Error(q);return console.warn(q),[0,0,0,0,0,0,0,0,0]}const y=1/f,S=[];return S[0]=(o[4]*o[8]-o[7]*o[5])*y,S[1]=(o[2]*o[7]-o[1]*o[8])*y,S[2]=(o[1]*o[5]-o[2]*o[4])*y,S[3]=(o[5]*o[6]-o[3]*o[8])*y,S[4]=(o[0]*o[8]-o[2]*o[6])*y,S[5]=(o[3]*o[2]-o[0]*o[5])*y,S[6]=(o[3]*o[7]-o[6]*o[4])*y,S[7]=(o[6]*o[1]-o[0]*o[7])*y,S[8]=(o[0]*o[4]-o[3]*o[1])*y,S})):i.map(((o,c)=>{const f=o[0],y=o[1],S=o[2],q=y,m=o[3],t=o[4],e=S,n=t,a=o[5],d=a*m-n*t,p=n*S-a*y,g=t*y-m*S,_=f*d+q*p+e*g;if(_===0){const w=`matrix at index${c} has a determinant = 0`;if(r===!0)throw new Error(w);return console.warn(w),[0,0,0,0,0,0]}const x=1/_;return[d*x,p*x,g*x,(a*f-e*S)*x,(e*y-n*f)*x,(m*f-q*y)*x]}))}return i.map(((o,c)=>{const f=[0,0,0,0];s===4?(f[0]=o[0],f[1]=o[1],f[2]=o[2],f[3]=o[3]):(f[0]=o[0],f[1]=o[1],f[2]=o[1],f[3]=o[2]);const y=f[0]*f[3]-f[1]*f[2];if(y===0){const q=`matrix at index${c} has a determinant = 0`;if(r===!0)throw new Error(q);return console.warn(q),s===3?[0,0,0]:[0,0,0,0]}const S=1/y;return s===3?[f[3]*S,-f[1]*S,f[0]*S]:[f[3]*S,-f[1]*S,-f[2]*S,f[0]*S]}))},z=(i,r,s=!1)=>{if(i===void 0)throw new Error("s is undefined");if(r===void 0)throw new Error("rot is undefined");if(s){if(Array.isArray(r)){if(i.itemSize===1)return i.clone();if(i.itemSize===3){const o=pt.transpose(r);return i.map((c=>pt.multVec(o,c)))}return i.itemSize===9?i.map((o=>pt.rotateInverse(pt.unpack(o),r))):i.map((o=>pt.pack(pt.rotateInverse(pt.unpack(o),r),!0)))}if(r.itemSize!==9)throw new Error("rot should have itemSize=9");return i.itemSize===1?i.clone():i.itemSize===3?wt(vt(r),i):wt(vt(r),wt(i,r))}if(Array.isArray(r))return i.itemSize===1?i.clone():i.itemSize===3?i.map((o=>pt.multVec(r,o))):i.itemSize===9?i.map((o=>pt.rotateForward(pt.unpack(o),r))):i.map((o=>pt.pack(pt.rotateForward(pt.unpack(o),r),!0)));if(r.itemSize!==9)throw new Error("rot should have itemSize=9");return i.itemSize===1?i.clone():i.itemSize===3?wt(r,i):wt(r,wt(i,vt(r)))},M=(i,r)=>{if(i===void 0)throw new Error("s is undefined");if(r===void 0)throw new Error("t is undefined");if(r.length!==i.itemSize)throw new Error(`t should be of length ${i.itemSize} (same as serie itemSize)`);return i.itemSize===1?i.map((s=>s*r[0])):i.map((s=>s.map(((o,c)=>o+r[c]))))},P=(i,r)=>{if(i===void 0)throw new Error("s is undefined");if(r===void 0)throw new Error("t is undefined");if(Array.isArray(r)){if(i.itemSize===1)return i.map((s=>s*r[0]));if(r.length!==i.itemSize)throw new Error(`t should be of length ${i.itemSize} (same as serie itemSize)`);return i.map((s=>s.map(((o,c)=>o*r[c]))))}return i.itemSize===1?i.map((s=>s*r)):i.map((s=>s.map((o=>o*r))))};function C(i){const r=[];i.forEach((c=>r.push(c)));let s,o=r.length;for(;o!=0;)s=Math.floor(Math.random()*o),o--,[r[o],r[s]]=[r[s],r[o]];return O.Serie.create({array:O.array.flatten(r),itemSize:i.itemSize,dimension:i.dimension})}function L(i){if(i===void 0)throw new Error("series is undefined");if(i.itemSize!==3&&i.itemSize!==4||i.dimension!==2){if(i.itemSize!==6&&i.itemSize!==9||i.dimension!==3)throw new Error("item size should be 3, 4, 6 or 9");{const r=s=>s.length===6?(0,O.symSquaredMatrix)(s):(0,O.squaredMatrix)(s);return i.map((s=>{const o=r(s);return o.at(0,0)*o.at(1,1)*o.at(2,2)-o.at(0,0)*o.at(1,2)*o.at(2,1)-o.at(0,1)*o.at(1,0)*o.at(2,2)+o.at(0,1)*o.at(1,2)*o.at(2,0)+o.at(0,2)*o.at(1,0)*o.at(2,1)-o.at(0,2)*o.at(1,1)*o.at(2,0)}))}}{const r=s=>s.length===3?(0,O.symSquaredMatrix)(s):(0,O.squaredMatrix)(s);return i.map((s=>{const o=r(s);return o.at(0,0)*o.at(1,1)-o.at(0,1)*o.at(1,0)}))}}const zt=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize!==6&&i.itemSize!==3)throw new Error("Series does not have itemSize = 3 or 6 (symmetric tensor [xx,xy,yy] or [xx,xy,xz,yy,yz,zz])");return i.map((r=>r.map((s=>-s))))};function xt(i,r){if(!i||!r)return;const s=new Array(r.count).fill(0);let o=0;return r.forEach((c=>{const f=i.itemAt(c[0]),y=i.itemAt(c[1]),S=i.itemAt(c[2]),q=ht.cross(ht.create(f,y),ht.create(f,S));s[o++]=q[0],s[o++]=q[1],s[o++]=q[2]})),O.Serie.create({array:(0,O.createTyped)(Float32Array,s,!0),itemSize:3})}const Ot=(i,r)=>{if(!i||!r)return;const s=xt(i,r);return s===void 0?void 0:Lt(Tt(s),2)};function ge(i,r){if(!i||!r)return;const s=new Array(r.count).fill(0);let o=0;return r.forEach((c=>{const f=i.itemAt(c[0]),y=i.itemAt(c[1]),S=i.itemAt(c[2]);s[o++]=(f[0]+y[0]+S[0])/3,s[o++]=(f[1]+y[1]+S[1])/3,s[o++]=(f[2]+y[2]+S[2])/3})),O.Serie.create({array:(0,O.createTyped)(Float32Array,s,!0),itemSize:3})}const Qt=i=>{if(i===void 0)throw new Error("series is undefined");const r=i.itemSize;if(r===1)return i.array.reduce(((o,c)=>o+c),0)/i.length;const s=new Array(r).fill(0);return i.forEach((o=>{for(let c=0;c<r;++c)s[c]+=o[c]/i.count})),s},Vt=(i,r)=>{if(i.length!==r.length)throw new Error("x and y must have the same length");if(i.itemSize!==1)throw new Error("x must have itemSize = 1");if(r.itemSize!==1)throw new Error("y must have itemSize = 1");const s=i.length,o=Qt(i),c=Qt(r);return ct(R(i,o),R(r,c)).array.reduce(((f,y)=>f+y/s),0)},ye=i=>Vt(i,i),Fe=(i,r)=>{if(i===void 0)throw new Error("s is undefined");if(r===void 0)throw new Error("w is undefined");if(r.count!==i.count)throw new Error(`count mismatch for s (${i.count}) and w (${r.count})`);if(r.itemSize!==1)throw new Error(`itemSize for w should be 1 (got ${r.itemSize})`);const s=r.array.reduce(((f,y)=>f+y),0),o=i.itemSize;if(o===1)return i.array.reduce(((f,y,S)=>f+y*r.array[S]),0)/s;const c=new Array(o).fill(0);return i.forEach(((f,y)=>{for(let S=0;S<o;++S)c[S]+=r.array[y]*f[S]})),c.map((f=>f/s))},Bt=(i,r)=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize!==1)throw new Error("quantile algorithm: itemSize must be 1");if(r<0)throw new Error("quantile must be >= 0");if(r>1)throw new Error("quantile must be <= 1");const s=(0,O.sort)(i).array,o=(s.length-1)*r,c=Math.floor(o),f=o-c;return s[c+1]!==void 0?s[c]+f*(s[c+1]-s[c]):s[c]},we=i=>Bt(i,.25),Te=i=>Bt(i,.5),oe=i=>Bt(i,.75),Qe=i=>Bt(i,.75)-Bt(i,.25),ae=(i,r)=>{const s=he(i,r);return(0,O.cut)(i,(o=>o<s.min||o>s.max))},xe=(i,r)=>{const s=he(i,r);return(0,O.check)(i,(o=>o<s.min||o>s.max))},Pt=(i,r=1.5)=>{const s=he(i,r);return(0,O.cut)(i,(o=>o>=s.min&&o<=s.max))},he=(i,r)=>{const s=we(i),o=oe(i),c=o-s;return{min:s-r*c,max:o+r*c}},Ve=i=>{if(i===void 0)throw new Error("series is undefined");if(i.itemSize!==1)throw new Error("quantile algorithm: itemSize must be 1");const r=Qt(i),s=i.map((o=>(o-r)**2));return Math.sqrt(bt(s)/(i.length-1))},ke=i=>{if(i===void 0)throw new Error("serie is undefined");if(i.itemSize!==1)throw new Error("serie must have itemSize = 1");return{count:i.count,mean:Qt(i),std:Ve(i),min:se(i),q25:we(i),q50:Te(i),q75:oe(i),max:ne(i)}};function _e(i,{size:r,nb:s,start:o,stop:c}){if(i.itemSize!==1)throw new Error("itemSize should be 1");if(r===void 0&&s===void 0)throw new Error("size or nb must be provided");const f=re(i);o===void 0&&(o=f[0]),c===void 0&&(c=f[1]),s!==void 0?r=(c-o)/s:s=Math.trunc(c-o)/r;const y=new Array(s).fill(0);return i.forEach((S=>{let q=Math.trunc((S-o)/r);if(q>=s&&(q=s-1),q<0||q>=s)throw new Error(`index for bin (${q}) out of bounds (0, ${s})`);y[q]++})),O.Serie.create({array:y,itemSize:1})}class Dt{names(r,s,o,c){if(c==="positions"||c==="indices")return[];const f=(0,O.nameOfSerie)(r,o);if(c===f&&o.itemSize===1)return[];if(s>1)return[];if(o.dimension===2)switch(o.itemSize){case 2:return Yt.map((S=>c+S));case 3:return ce.map((S=>c+S));case 4:return ue.map((S=>c+S))}else switch(o.itemSize){case 3:return Oe.map((S=>c+S));case 6:return Be.map((S=>c+S));case 9:return Pe.map((S=>c+S))}const y=[];for(let S=0;S<s;++S)y.push(c+S);return y}serie(r,s,o){if(s>1)return;let c=o.substring(0,o.length-1),f=r.series[c];if(f){if(f.dimension===2){for(let y=0;y<Yt.length;++y)if(o===c+Yt[y])return(0,O.apply)(f,(S=>S[y]))}else for(let y=0;y<Oe.length;++y)if(o===c+Oe[y])return(0,O.apply)(f,(S=>S[y]))}if(c=o.substring(0,o.length-2),f=r.series[c],f)if(f.dimension===2){for(let y=0;y<ce.length;++y)if(o===c+ce[y])return(0,O.apply)(f,(S=>S[y]));for(let y=0;y<ue.length;++y)if(o===c+ue[y])return(0,O.apply)(f,(S=>S[y]))}else{for(let y=0;y<Be.length;++y)if(o===c+Be[y])return(0,O.apply)(f,(S=>S[y]));for(let y=0;y<Pe.length;++y)if(o===c+Pe[y])return(0,O.apply)(f,(S=>S[y]))}if(c=o.substring(0,o.length-1),f=r.series[c],f){for(let y=0;y<s;++y)if(o===c+y)return(0,O.apply)(f,(S=>S[y]))}}}const Yt=["x","y"],ce=["xx","xy","yy"],ue=["xx","xy","yx","yy"],Oe=["x","y","z"],Be=["xx","xy","xz","yy","yz","zz"],Pe=["xx","xy","xz","yx","yy","yz","zx","zy","zz"];class Ze{constructor(r=["x","y","z"]){if(this.names_=r,r.length!==3)throw new Error("names must be an array of 3 strings (the dimension)")}names(r,s,o,c){return s!==1||c!=="positions"?[]:this.names_}serie(r,s,o){if(s===1){const c=r.series.positions;switch(o){case this.names_[0]:return(0,O.apply)(c,(f=>f[0]));case this.names_[1]:return(0,O.apply)(c,(f=>f[1]));case this.names_[2]:return(0,O.apply)(c,(f=>f[2]))}}}}class He{names(r,s,o,c){return c==="positions"||c==="indices"?[]:(o.dimension!==2||o.itemSize===3&&s===1)&&(o.dimension!==3||o.itemSize===6&&s===1)?o.dimension===2?[c+"1",c+"2"]:[c+"1",c+"2",c+"3"]:[]}serie(r,s,o){if(s!==1)return;const c=o.substring(0,o.length-1),f=r.series[c],y=parseInt(o.charAt(o.length-1));if(f!==void 0){if(f.dimension===2){if(f.itemSize!==3||y<1||y>2)return}else if(f.itemSize!==6||y<1||y>3)return;return(0,O.apply)(J(f),(S=>S[y-1]))}}}class ti{names(r,s,o,c){return c==="positions"||c==="indices"?[]:o.dimension===2?o.itemSize!==3||s!==2?[]:[c+"1",c+"2"]:o.itemSize!==6||s!==3?[]:[c+"1",c+"2",c+"3"]}serie(r,s,o){const c=o.substring(0,o.length-1);let f=parseInt(o.charAt(o.length-1));const y=r.series[c];if(y!==void 0){if(y.dimension===2)return s!==2||y===void 0||y.itemSize!==3||f<1||f>2?void 0:(f-=1,(0,O.apply)(D(y),(S=>[S[2*f],S[2*f+1]])));if(s===3&&y!==void 0&&y.itemSize===6&&!(f<1||f>3))return f-=1,(0,O.apply)(D(y),(S=>[S[3*f],S[3*f+1],S[3*f+2]]))}}}class $e{names(r,s,o,c){return c==="positions"||c==="indices"||o.itemSize<=1||s!==1?[]:o.dimension===2&&o.itemSize===2||o.dimension===3&&o.itemSize===3?[c]:[]}serie(r,s,o){if(s!==1||o==="positions"||o==="indices")return;const c=r.series[o];return c===void 0||c.itemSize<=1?void 0:c.dimension===2&&c.itemSize===2||c.dimension===3&&c.itemSize===3?Tt(c):void 0}}class Re{constructor(r="normals"){this.name=r}names(r,s,o,c){return s!==3?[]:(0,O.exists)(r,"positions")||(0,O.exists)(r,"indices")?[this.name]:[]}serie(r,s,o){if(o!==this.name)return;const c=r.series.positions,f=r.series.indices;if(!c||!f)return;const y=new Array(f.count).fill(0);let S=0;return f.forEach((q=>{const m=c.itemAt(q[0]),t=c.itemAt(q[1]),e=c.itemAt(q[2]),n=ht.cross(ht.create(m,t),ht.create(m,e));y[S++]=n[0],y[S++]=n[1],y[S++]=n[2]})),O.Serie.create({array:(0,O.createTyped)(Float32Array,y,!0),itemSize:3})}}class Le{constructor(r="valence"){this.name=r}names(r,s,o,c){return s!==1?[]:(0,O.exists)(r,"positions")||(0,O.exists)(r,"indices")?[this.name]:[]}serie(r,s,o){if(o!==this.name)return;const c=r.series.positions,f=r.series.indices;if(!c||!f)return;const y=new Array(c.count).fill(0);return f.forEach((S=>{y[S[0]]++,y[S[1]]++,y[S[2]]++})),O.Serie.create({array:(0,O.createTyped)(Int8Array,y,!0),itemSize:1})}}class ei{constructor(r="area"){this.name=r}names(r,s,o,c){return s!==1?[]:(0,O.exists)(r,"positions")||(0,O.exists)(r,"indices")?[this.name]:[]}serie(r,s,o){if(o!==this.name)return;const c=new Re().serie(r,s,"normals");return c?Lt(Tt(c),2):void 0}}class ii{constructor(r,s){this.name=r,this.fringes=s}names(r,s,o,c){return s!==1?[]:[this.name]}serie(r,s,o){if(o!==this.name)return;const c=r.series[this.name];return c?(0,O.apply)(c,(f=>{return Math.abs(this.fringes*((y=f/this.fringes)-Math.floor(y)));var y})):void 0}}const ri=1e-5,de=100,si=Math.cos(Math.PI/4),Nt=Math.sin(Math.PI/4);function jt(i){const r=[],s=[],o=[],c=[],f=[];let y=0,S=0,q=0,m=0,t=0,e=0,n=0,a=0,d=0,p=0,g=0,_=0,x=0,w=0,v=0,b=0,N=0;if(i.length===3)N=2,o[0]=i[0],o[1]=i[1],o[2]=i[2];else if(i.length===4)N=2,o[0]=i[0],o[1]=i[1],o[2]=i[3];else if(i.length===6)N=3,o[0]=i[0],o[1]=i[1],o[2]=i[3],o[3]=i[2],o[4]=i[4],o[5]=i[5];else{if(i.length!==9)throw new Error(`matrix-array should be of size 2 (xx,xy,yy),
        4 (xx,xy,yx,yy), 6 (xx,xy,xz,yy,yz,zz) or 9 (xx,xy,xz,yx,yy,yz,zx,zy,zz).
        Got ${i.length}`);N=3,o[0]=i[0],o[1]=i[1],o[2]=i[4],o[3]=i[2],o[4]=i[5],o[5]=i[8]}const E=N*(N+1)/2;let I=0;for(let B=0;B<N;++B)for(let F=0;F<N;++F)c[I++]=B===F?1:0;I=1;let T=0;for(let B=1;B<=N;++B)for(let F=1;F<=B;++F)B!==F&&(d=o[I-1],T+=d*d),++I;if(T!==0){const B=T*ri;let F=T;for(;F>B&&y<de;){++y,S=F/E;for(let j=1;j<N;++j)for(let H=j+1;H<=N;++H){const nt=(j*j-j)/2,it=(H*H-H)/2,Y=j+it,tt=o[Y-1],dt=tt*tt;if(dt<S)continue;const V=j+nt,K=H+it,X=o[V-1],Q=o[K-1],ot=X-Q;ot===0?(w=-Math.PI/4,v=Nt,b=si):(w=-Math.atan((tt+tt)/ot)/2,v=Math.sin(w),b=Math.cos(w));const lt=v*v,et=b*b,W=v*b;let $=N*(j-1),rt=N*(H-1);for(let G=1;G<=N;++G)G!==j&&G!==H&&(n=(G*G-G)/2,e=G<H?G+it:H+n,p=o[e-1],a=G<j?G+nt:j+n,g=o[a-1],o[a-1]=g*b-p*v,o[e-1]=g*v+p*b),++$,++rt,_=c[$-1],x=c[rt-1],c[$-1]=b*_-v*x,c[rt-1]=v*_+b*x;w=tt*W,w+=w,o[V-1]=X*et+Q*lt-w,o[K-1]=X*lt+Q*et+w,o[Y-1]=0,F=Math.abs(F-dt)}}}for(let B=0;B<N;++B)m=B+B*(B+1)/2,r[B]=o[m],f[B]=B;for(let B=0;B<N-1;++B){w=r[B],m=B;for(let F=B+1;F<N;++F)w<r[F]&&(m=F,w=r[F]);r[m]=r[B],r[B]=w,q=f[m],f[m]=f[B],f[B]=q}I=0;for(let B=0;B<N;++B){t=f[B]*N;for(let F=0;F<N;++F)s[I++]=c[t++]}return{values:r,vectors:s}}class De{constructor(){this.eigenValues=[],this.eigenVectors=[],console.warn("Deprecated class. Use instead eigen(mat: Array<number>")}compute(r){const s=jt(r);return this.eigenValues=s.values,this.eigenVectors=s.vectors,s}vector(r){return console.assert(r>=0&&r<3),[this.eigenVectors[3*r],this.eigenVectors[3*r+1],this.eigenVectors[3*r+2]]}get vectors(){return this.eigenVectors}value(r){return console.assert(r>=0&&r<3),this.eigenValues[r]}get values(){return this.eigenValues}}const Kt=(i,r)=>i.reduce(((s,o,c)=>s+o*r[c]),0),Zt=(i,r)=>i.reduce(((s,o,c)=>s+o*r[c]),0),ve=(i,r)=>[r[0]-i[0],r[1]-i[1]],Se=(i,r)=>[r[0]-i[0],r[1]-i[1],r[2]-i[2]];function _t(i,r,s,o){const c=ve(r,s),f=ve(r,o),y=ve(r,i),S=Kt(c,c),q=Kt(c,f),m=Kt(f,f),t=Kt(y,c),e=Kt(y,f),n=1/(S*m-q*q),a=(m*t-q*e)*n,d=(S*e-q*t)*n;return[1-a-d,a,d]}function je(i,r,s,o){const c=Se(r,s),f=Se(r,o),y=Se(r,i),S=Zt(c,c),q=Zt(c,f),m=Zt(f,f),t=Zt(y,c),e=Zt(y,f),n=1/(S*m-q*q),a=(m*t-q*e)*n,d=(S*e-q*t)*n;return[1-a-d,a,d]}function Ge(i,r,s,o,c){const f=n=>[n[0],n[1],n[2],1],y=f(r),S=f(s),q=f(o),m=f(c),t=f(i),e=Ht(y,S,q,m);return[Ht(t,S,q,m)/e,Ht(y,t,q,m)/e,Ht(y,S,t,m)/e,Ht(y,S,q,t)/e]}function Ht(i,r,s,o){return i[3]*r[2]*s[1]*o[0]-i[2]*r[3]*s[1]*o[0]-i[3]*r[1]*s[2]*o[0]+i[1]*r[3]*s[2]*o[0]+i[2]*r[1]*s[3]*o[0]-i[1]*r[2]*s[3]*o[0]-i[3]*r[2]*s[0]*o[1]+i[2]*r[3]*s[0]*o[1]+i[3]*r[0]*s[2]*o[1]-i[0]*r[3]*s[2]*o[1]-i[2]*r[0]*s[3]*o[1]+i[0]*r[2]*s[3]*o[1]+i[3]*r[1]*s[0]*o[2]-i[1]*r[3]*s[0]*o[2]-i[3]*r[0]*s[1]*o[2]+i[0]*r[3]*s[1]*o[2]+i[1]*r[0]*s[3]*o[2]-i[0]*r[1]*s[3]*o[2]-i[2]*r[1]*s[0]*o[3]+i[1]*r[2]*s[0]*o[3]+i[2]*r[0]*s[1]*o[3]-i[0]*r[2]*s[1]*o[3]-i[1]*r[0]*s[2]*o[3]+i[0]*r[1]*s[2]*o[3]}function Ye(i){let r=Number.POSITIVE_INFINITY;const s=i.length;for(let o=0;o<s;++o){const c=i[o];c<r&&(r=c)}return r}function St(i){let r=Number.NEGATIVE_INFINITY;const s=i.length;for(let o=0;o<s;++o){const c=i[o];c>r&&(r=c)}return r}function yt(i){let r=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const o=i.length;for(let c=0;c<o;++c){const f=i[c];f<r&&(r=f),f>s&&(s=f)}return[r,s]}function Ke(i){const r=yt(i);return i.map((s=>(s-r[0])/(r[1]-r[0])))}function Et(i,r){return i.map((s=>s*r))}function ze(i){return i.map(((r,s)=>({value:r,i:s}))).filter((r=>Number.isNaN(r.value))).map((r=>r.i))}function Ue(i){const r=[];return i.forEach((s=>r.push(...s))),r}function Mt(i,r,s,o,c){const f=1/(s-r);return o*(s-i)*f+c*(i-r)*f}function Ce(i,r,s,o,c,f,y){const S=Mt(i[0],r[0],s[0],o,f),q=Mt(i[0],r[0],s[0],c,y);return Mt(i[1],r[1],s[1],S,q)}function ni(i,r,s,o,c,f,y,S,q,m,t){const e=Mt(i[0],r[0],s[0],o,S),n=Mt(i[0],r[0],s[0],f,m),a=Mt(i[0],r[0],s[0],c,q),d=Mt(i[0],r[0],s[0],y,t),p=Mt(i[1],r[1],s[1],e,a),g=Mt(i[1],r[1],s[1],n,d);return Mt(i[2],r[2],s[2],p,g)}function te(i,r,s,o,c,f,y){const S=_t(i,r,s,o);if(Array.isArray(c))return c.map(((t,e)=>t*S[0]+f[e]*S[1]+y[e]*S[2]));const q=f,m=y;return S[0]*c+S[1]*q+S[2]*m}function mt(i,r,s,o,c,f,y){const S=je(i,r,s,o);if(Array.isArray(c))return c.map(((t,e)=>t*S[0]+f[e]*S[1]+y[e]*S[2]));const q=f,m=y;return S[0]*c+S[1]*q+S[2]*m}function oi(i,r,s,o,c,f,y,S,q){const m=Ge(i,r,s,o,c);if(Array.isArray(f))return f.map(((a,d)=>a*m[0]+y[d]*m[1]+S[d]*m[2]+q[d]*m[3]));const t=y,e=S,n=q;return m[0]*f+m[1]*t+m[2]*e+m[3]*n}var $t,ht;function We({attribute:i,topology:r,size:s=3,direction:o=$t.INCREASING}){let c;if(i!==void 0)if(i.length!==0)if(r!==void 0)if(r.length!==0){if(Array.isArray(r[0]))c=r;else{if(c=[],r.length%s!=0)throw new Error(`Cannot meshInterpolate, topology (of size ${r.length}) is not divisable by ${s}`);for(let f=0;f<r.length;f+=s){const y=[];for(let S=0;S<s;++S)y.push(r[f+S]);c.push(y)}}switch(o){case $t.INCREASING:return(function({from:f,topology:y}){if(It(y)[0]<0)throw new Error("Topology contains negatif indices");let S=f[0];S=Array.isArray(S)?S.slice().fill(0):0;const q=new Array(y.length).fill(S);return typeof S=="number"?y.forEach(((m,t)=>{q[t]=m.reduce(((e,n)=>e+f[n]))/m.length})):y.forEach(((m,t)=>{let e=S.slice();m.forEach((n=>{const a=f[n];e=e.map(((d,p)=>d+a[p]))})),q[t]=Et(e,1/m.length)})),q})({from:i,topology:c});case $t.DECREASING:return(function({from:f,topology:y}){const S=It(y);if(S[0]<0)throw new Error("Topology contains negatif indices");let q,m=f[0],t=1;Array.isArray(m)?(m=m.slice().fill(0),t=m.length,q=new Array(S[1]+1).fill(void 0).map((n=>m.slice()))):(m=0,q=new Array(S[1]+1).fill(0));const e=new Array(q.length).fill(0);if(Array.isArray(m)){y.forEach(((n,a)=>{const d=f[a];n.forEach((p=>{const g=q[p];for(let _=0;_<t;++_)g[_]+=d[_];e[p]++}))}));for(let n=0;n<q.length;++n)for(let a=0;a<t;++a)q[n][a]/=e[n]}else{const n=q;y.forEach(((a,d)=>{const p=f[d];a.forEach((g=>{n[g]+=p,e[g]++}))}));for(let a=0;a<q.length;++a)n[a]/=e[a]}return q})({from:i,topology:c})}}else console.warn("Cannot meshInterpolate, topology is empty");else console.warn("Cannot meshInterpolate, attribute is topology");else console.warn("Cannot meshInterpolate, attribute is empty");else console.warn("Cannot meshInterpolate, attribute is undefined")}function It(i){const r=[1/0,-1/0];return i.forEach((s=>{const o=yt(s);r[0]=Math.min(r[0],o[0]),r[1]=Math.max(r[1],o[1])})),r}(function(i){i[i.INCREASING=0]="INCREASING",i[i.DECREASING=1]="DECREASING"})($t||($t={}));class ai{constructor(r){this.m_=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],r!==void 0&&this.add(r)}reset(){this.m_=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]}get min(){return this.m_[0]}get max(){return this.m_[1]}get length(){return this.m_[1]-this.m_[0]}get value(){return this.m_}normalize(r){return(r-this.min)/(this.max-this.min)}add(r){if(Array.isArray(r))r.forEach((s=>{s<this.m_[0]&&(this.m_[0]=s),s>this.m_[1]&&(this.m_[1]=s)}));else{const s=r;s<this.m_[0]&&(this.m_[0]=s),s>this.m_[1]&&(this.m_[1]=s)}return this}}(function(i){i.create=(r,s)=>s.map(((o,c)=>o-r[c])),i.norm2=r=>r.reduce(((s,o)=>s+o**2),0),i.norm=r=>Math.sqrt(i.norm2(r)),i.add=(r,s)=>r.map(((o,c)=>o+s[c])),i.sub=(r,s)=>r.map(((o,c)=>o-s[c])),i.scale=(r,s)=>r.map((o=>o*s)),i.setCoord=(r,s,o)=>r[s]=o,i.set=(r,s)=>s.forEach(((o,c)=>r[c]=s[c])),i.dot=(r,s)=>r.reduce(((o,c,f)=>o+c*s[f]),0),i.cross=(r,s)=>[r[1]*s[2]-r[2]*s[1],r[2]*s[0]-r[0]*s[2],r[0]*s[1]-r[1]*s[0]],i.normalize=r=>{const s=i.norm(r);return r.map((o=>o/s))},i.clone=r=>[...r]})(ht||(ht={}));const Xe=(i,r,s)=>{i[r][0]=s[0],i[r][1]=s[1],i[r][2]=s[2]};class st{constructor(){this.q=[0,0,0,1]}static fromAxisAngle(r,s){const o=new st;return o.setAxisAngle(r,s),o}static fromProd(r,s){const o=new st;return o.q[0]=r.q[3]*s.q[0]+s.q[3]*r.q[0]+r.q[1]*s.q[2]-r.q[2]*s.q[1],o.q[1]=r.q[3]*s.q[1]+s.q[3]*r.q[1]+r.q[2]*s.q[0]-r.q[0]*s.q[2],o.q[2]=r.q[3]*s.q[2]+s.q[3]*r.q[2]+r.q[0]*s.q[1]-r.q[1]*s.q[0],o.q[3]=r.q[3]*s.q[3]-s.q[0]*r.q[0]-r.q[1]*s.q[1]-r.q[2]*s.q[2],o}static fromBase(r,s,o){const c=new st;return c.setFromBase(r,s,o),c}static fromRotationMatrix(r){const s=new st;return s.setFromRotationMatrix(r),s}static fromTo(r,s){const o=new st;return o.setFromTo(r,s),o}get data(){return this.q}get axis(){const r=[this.q[0],this.q[1],this.q[2]],s=ht.norm(r);return s>1e-8&&ht.scale(r,1/s),Math.acos(this.q[3])<=Math.PI/2?r:ht.scale(r,-1)}get angle(){const r=2*Math.acos(this.q[3]);return r<=Math.PI?r:2*Math.PI-r}equals(r){for(let s=0;s<4;++s)if(this.q[s]!==r.q[s])return!1;return!0}notEquals(r){return!this.equals(r)}prod(r){const s=st.fromProd(this,r);return this.setFrom(s)}inverse(){const r=new st;for(let s=0;s<3;++s)r.q[s]=-this.q[s];return r.q[3]=this.q[3],r}invert(){return this.q[0]*=-1,this.q[1]*=-1,this.q[2]*=-1,this}negate(){return this.invert(),this.q[3]*=-1,this}normalize(){const r=this.q,s=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]+r[3]*r[3]);for(let o=0;o<4;++o)r[o]/=s;return s}dot(r,s){const o=r.q,c=s.q;return o[0]*c[0]+o[1]*c[1]+o[2]*c[2]+o[3]*c[3]}iRotate(r){const s=this.q,o=2*s[0]*s[0],c=2*s[1]*s[1],f=2*s[2]*s[2],y=2*s[0]*s[1],S=2*s[0]*s[2],q=2*s[0]*s[3],m=2*s[1]*s[2],t=2*s[1]*s[3],e=2*s[2]*s[3];return[(1-c-f)*r[0]+(y+e)*r[1]+(S-t)*r[2],(y-e)*r[0]+(1-f-o)*r[1]+(m+q)*r[2],(S+t)*r[0]+(m-q)*r[1]+(1-c-o)*r[2]]}rotate(r){const s=this.q,o=2*s[0]*s[0],c=2*s[1]*s[1],f=2*s[2]*s[2],y=2*s[0]*s[1],S=2*s[0]*s[2],q=2*s[0]*s[3],m=2*s[1]*s[2],t=2*s[1]*s[3],e=2*s[2]*s[3];return[(1-c-f)*r[0]+(y-e)*r[1]+(S+t)*r[2],(y+e)*r[0]+(1-f-o)*r[1]+(m-q)*r[2],(S-t)*r[0]+(m+q)*r[1]+(1-c-o)*r[2]]}toMatrix(){this.normalize();const r=this.q,s=[[0,0,0],[0,0,0],[0,0,0]],o=r[0],c=r[1],f=r[2],y=r[3];return s[0][0]=2*(o*o+c*c)-1,s[0][1]=2*(c*f-o*y),s[0][2]=2*(c*y+o*f),s[1][0]=2*(c*f+o*y),s[1][1]=2*(o*o+f*f)-1,s[1][2]=2*(f*y-o*c),s[2][0]=2*(c*y-o*f),s[2][1]=2*(f*y+o*c),s[2][2]=2*(o*o+y*y)-1,s}setFrom(r){for(let s=0;s<4;++s)this.q[s]=r.q[s];return this}setAxisAngle(r,s){const o=ht.norm(r);if(o<1e-9)this.q[0]=0,this.q[1]=0,this.q[2]=0,this.q[3]=1;else{const c=Math.sin(s/2);this.q[0]=c*r[0]/o,this.q[1]=c*r[1]/o,this.q[2]=c*r[2]/o,this.q[3]=Math.cos(s/2)}return this}setFromTo(r,s){const c=ht.norm2(r),f=ht.norm2(s),y=ht.cross(r,s),S=ht.norm2(y),q=this.q,m=ht.dot(r,s)/Math.sqrt(c*f);if(m<0&&1-Math.abs(m)<1e-10)return q[0]=q[1]=q[2]=0,q[3]=1,this;if(c<1e-10||f<1e-10||S<1e-10)q[0]=q[1]=q[2]=0,q[3]=1;else{let t=Math.asin(Math.sqrt(S/c/f));ht.dot(r,s)<0&&(t=Math.PI-t),this.setAxisAngle(y,t)}return this}setFromRotationMatrix(r){let s=2;if(r[0][0]>r[1][1]?r[0][0]>r[2][2]&&(s=0):r[1][1]>r[2][2]&&(s=1),r[0][0]+r[1][1]+r[2][2]>r[s][s])this.q[3]=Math.sqrt(r[0][0]+r[1][1]+r[2][2]+1)/2,this.q[0]=(r[2][1]-r[1][2])/(4*this.q[3]),this.q[1]=(r[0][2]-r[2][0])/(4*this.q[3]),this.q[2]=(r[1][0]-r[0][1])/(4*this.q[3]);else{const o=(s+1)%3,c=(s+2)%3;this.q[s]=Math.sqrt(r[s][s]-r[o][o]-r[c][c]+1)/2,this.q[o]=(r[s][o]+r[o][s])/(4*this.q[s]),this.q[c]=(r[s][c]+r[c][s])/(4*this.q[s]),this.q[3]=(r[c][o]-r[o][c])/(4*this.q[s])}return this}setFromBase(r,s,o){const c=[[0,0,0],[0,0,0],[0,0,0]],f=ht.norm(r),y=ht.norm(s),S=ht.norm(o);for(let q=0;q<3;++q)Xe(c,q,[r[q]/f,s[q]/y,o[q]/S]);return this.setFromRotationMatrix(c)}}function hi(i,r,s){const o=ht.norm(i),c=[0,0,0,1];if(o>1e-9){const d=Math.sin(.5*r)/o;c[0]=d*i[0],c[1]=d*i[1],c[2]=d*i[2],c[3]=Math.cos(.5*r)}const f=2*c[0]**2,y=2*c[1]**2,S=2*c[2]**2,q=2*c[0]*c[1],m=2*c[0]*c[2],t=2*c[0]*c[3],e=2*c[1]*c[2],n=2*c[1]*c[3],a=2*c[2]*c[3];return[(1-y-S)*s[0]+(q-a)*s[1]+(m+n)*s[2],(q+a)*s[0]+(1-S-f)*s[1]+(e-t)*s[2],(m-n)*s[0]+(e+t)*s[1]+(1-y-f)*s[2]]}function qt(i,r){if(Array.isArray(i))return st.fromAxisAngle(i,r).toMatrix();let s=2;i==="x"||i==="X"?s=0:i!=="y"&&i!=="Y"||(s=1);const o=[[0,0,0],[0,0,0],[0,0,0]],c=Math.cos(r*Math.PI/180),f=Math.sin(r*Math.PI/180);return s===2?(o[0][0]=c,o[0][1]=-f,o[1][0]=f,o[1][1]=c,o[2][2]=1):s===0?(o[0][0]=1,o[1][1]=c,o[1][2]=-f,o[2][1]=f,o[2][2]=c):(o[0][0]=c,o[0][2]=f,o[2][0]=-f,o[1][1]=1,o[2][2]=c),o}var pt;(function(i){function r(f){return f.length===6?[[f[0],f[1],f[2]],[f[1],f[3],f[4]],[f[2],f[4],f[5]]]:[[f[0],f[1],f[2]],[f[3],f[4],f[5]],[f[6],f[7],f[8]]]}function s(f,y){const S=[[0,0,0],[0,0,0],[0,0,0]];return S[0][0]=f[0][0]*y[0][0]+f[0][1]*y[1][0]+f[0][2]*y[2][0],S[0][1]=f[0][0]*y[0][1]+f[0][1]*y[1][1]+f[0][2]*y[2][1],S[0][2]=f[0][0]*y[0][2]+f[0][1]*y[1][2]+f[0][2]*y[2][2],S[1][0]=f[1][0]*y[0][0]+f[1][1]*y[1][0]+f[1][2]*y[2][0],S[1][1]=f[1][0]*y[0][1]+f[1][1]*y[1][1]+f[1][2]*y[2][1],S[1][2]=f[1][0]*y[0][2]+f[1][1]*y[1][2]+f[1][2]*y[2][2],S[2][0]=f[2][0]*y[0][0]+f[2][1]*y[1][0]+f[2][2]*y[2][0],S[2][1]=f[2][0]*y[0][1]+f[2][1]*y[1][1]+f[2][2]*y[2][1],S[2][2]=f[2][0]*y[0][2]+f[2][1]*y[1][2]+f[2][2]*y[2][2],S}function o(f){return[[f[0][0],f[1][0],f[2][0]],[f[0][1],f[1][1],f[2][1]],[f[0][2],f[1][2],f[2][2]]]}function c(f,y){return s(y,s(f,o(y)))}i.unpack=r,i.pack=function(f,y=!0){return y?[f[0][0],f[0][1],f[0][2],f[1][1],f[1][2],f[2][2]]:[f[0][0],f[0][1],f[0][2],f[1][0],f[1][1],f[1][2],f[2][0],f[2][1],f[2][2]]},i.det=function(f){return f[0][0]*f[1][1]*f[2][2]-f[0][0]*f[1][2]*f[2][1]-f[0][1]*f[1][0]*f[2][2]+f[0][1]*f[1][2]*f[2][0]+f[0][2]*f[1][0]*f[2][1]-f[0][2]*f[1][1]*f[2][0]},i.multMat=s,i.multVec=function(f,y){const S=y[0],q=y[1],m=y[2];return[f[0][0]*S+f[0][1]*q+f[0][2]*m,f[1][0]*S+f[1][1]*q+f[1][2]*m,f[2][0]*S+f[2][1]*q+f[2][2]*m]},i.multTVec=function(f,y){const S=y[0],q=y[1],m=y[2];return[f[0][0]*S+f[1][0]*q+f[2][0]*m,f[0][1]*S+f[1][1]*q+f[2][1]*m,f[0][2]*S+f[1][2]*q+f[2][2]*m]},i.inv=function(f,y){const S=f[0][0],q=f[0][1],m=f[0][2],t=f[1][0],e=f[1][1],n=f[1][2],a=f[2][0],d=f[2][1],p=f[2][2],g=p*e-n*d,_=n*a-p*t,x=d*t-e*a,w=S*g+q*_+m*x;if(w===0){const b="Matrix3: .getInverse() can't invert matrix, determinant is 0";if(y===!0)throw new Error(b);return console.warn(b),this.identity()}const v=1/w;return[[g*v,(m*d-p*q)*v,(n*q-m*e)*v],[_*v,(p*S-m*a)*v,(m*t-n*S)*v],[x*v,(q*a-d*S)*v,(e*S-q*t)*v]]},i.transpose=o,i.transposeSelf=function(f){let y;return y=f[0][1],f[0][1]=f[1][0],f[1][0]=y,y=f[0][2],f[0][2]=f[2][0],f[2][0]=y,y=f[1][2],f[1][2]=f[2][1],f[2][1]=y,this},i.rotate=function(f,y,S){return c(f,qt(S,y))},i.rotateInverse=function(f,y){return s(o(y),s(f,y))},i.rotateForward=c,i.makeRotationX=function(f){const y=Math.cos(f*Math.PI/180),S=Math.sin(f*Math.PI/180);return r([1,0,0,0,y,-S,0,S,y])},i.makeRotationY=function(f){const y=Math.cos(f*Math.PI/180),S=Math.sin(f*Math.PI/180);return r([y,0,S,0,1,0,-S,0,y])},i.makeRotationZ=function(f){const y=Math.cos(f*Math.PI/180),S=Math.sin(f*Math.PI/180);return r([y,-S,0,S,y,0,0,0,1])}})(pt||(pt={}));const ci=(i,r=!1)=>{let s=(function(){Ee==0&&(ui||(function(c){Ft[0]=c;for(let f=1;624>f;++f)Ft[f]=1812433253*(Ft[f-1]^Ft[f]>>30)+f&4294967295})(+new Date),(function(){for(let c=0;624>c;++c){const f=2147483648&Ft[c]|2147483647&Ft[(c+1)%624];Ft[c]=Ft[(c+397)%624]^f>>1,f%2==1&&(Ft[c]^=2567483615)}})());let o=Ft[Ee];return o^=o>>11,o^=o<<7&2636928640,o^=o<<15&4022730752,o^=o>>18,Ee=(Ee+1)%624,o/2147483648})();return i!=null&&(s*=i),r?~~s:s},Ft=[];let Ee=0;const ui=!1;function di(i,{x:r=0,y:s=0,z:o=0,lx:c,Lx:f,ly:y,Ly:S,nx:q,ny:m,name:t}){const e=f/(q-1),n=S/(m-1),a=i.series.positions,d=i.series[t];if(a===void 0)throw new Error("positions is undefined");if(d===void 0)throw new Error(`attribute named ${t} is undefined`);const p=new l(c,y),g=[],_=[];for(let x=0;x<q;++x){p.x=r+x*e;for(let w=0;w<m;++w)p.y=s+w*n,_.push(p.x,p.y,o),g.push(p.density(a,d))}return{nx:q,ny:m,positions:O.Serie.create({array:_,itemSize:3}),solution:O.Serie.create({array:g,itemSize:d.itemSize})}}class l{constructor(r,s){this.w=r,this.h=s,this.x=0,this.y=0}contains(r){return r[0]>=this.x&&r[1]>=this.y&&r[0]<=this.x+this.w&&r[1]<=this.y+this.h}density(r,s){let o,c=0;return o=s.itemSize===1?0:new Array(s.itemSize).fill(0),(0,O.forEach)([r,s],(([f,y])=>{if(this.contains(f))if(c++,s.itemSize===1)o+=y;else for(let S=0;S<s.itemSize;++S)o[S]+=y[S]})),s.itemSize===1?c===0?0:o/c:c===0?o:o.map((f=>f/c))}}function h(i,r=100){let s=[],o=0;for(let f=0;f<r;++f)o+=i(f/(r-1)),s.push(o);s=s.map((f=>f/o));const c=1/r;return f=>{if(f<s[0])return f/s[0]*c;const y=u(s,f);return(y+(f-s[y-1])/(s[y]-s[y-1]))*c}}const u=(i,r)=>{let s=0,o=i.length;for(;s<o;){const c=Math.floor((s+o)/2);i[c]<r?s=c+1:o=c}return s}})(),ft})()))})(pi)),pi.exports}/*! For license information please see geometry.js.LICENSE.txt */var Mi=mi.exports,_i;function Ii(){return _i||(_i=1,(function(le,Ae){(function(At,gt){le.exports=gt(Ni(),gi())})(typeof self<"u"?self:Mi,((At,gt)=>(()=>{var ut={518:D=>{D.exports=gt},48:D=>{D.exports=At}},Z={};function ft(D){var U=Z[D];if(U!==void 0)return U.exports;var at=Z[D]={exports:{}};return ut[D](at,at.exports,ft),at.exports}ft.d=(D,U)=>{for(var at in U)ft.o(U,at)&&!ft.o(D,at)&&Object.defineProperty(D,at,{enumerable:!0,get:U[at]})},ft.o=(D,U)=>Object.prototype.hasOwnProperty.call(D,U),ft.r=D=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(D,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(D,"__esModule",{value:!0})};var J={};return(()=>{ft.r(J),ft.d(J,{Action:()=>Dt,ActionPool:()=>ue,BBox:()=>U,BackgroundGrid2D:()=>M,CurvatureDecomposer:()=>oi,Facet:()=>we,FillHoleAction:()=>Pe,FunctionAction:()=>Yt,Grid2DHelper:()=>k,Grid3DHelper:()=>A,Halfedge:()=>Te,HarmonicDiffusion:()=>ei,InterpolateInGrid2D:()=>Le,InterpolateSerieFromCsysOnSurface:()=>Ze,MacroAction:()=>ce,MarchingCubes:()=>xt,MarchingSquares:()=>ri,MoveNodeAction:()=>Oe,Node:()=>Bt,Normalizer:()=>je,NormalsToNodeDecomposer:()=>te,Square:()=>ii,Surface:()=>Pt,SurfaceBuilder:()=>xe,SurfaceEditor:()=>_e,TriangleCSys:()=>ct,TriangleToNodeDecomposer:()=>mt,Vector:()=>_t,bbox:()=>i,createBackgroundGrid2D:()=>z,ctriangulate:()=>q,distanceFromPointToPlane:()=>wt,extractSurfaceBorders:()=>ti,extrude:()=>De,facetArea:()=>ye,facetNormal:()=>Fe,facetsAroundNode:()=>ke,fittingPlane:()=>O,fromNodeToTriangle:()=>ni,fromTriangleToNode:()=>Ce,generateEllipse:()=>kt,generatePointInPolygon:()=>Re,generateRectangle:()=>re,generateSphere:()=>qe,generateStreamLinesFromUnstructured:()=>Mt,getDimsGrid2D:()=>Se,inflateBBox:()=>at,mapToMnt:()=>Zt,nodesAroundHalfedge:()=>Ve,nodesAroundNode:()=>he,pointInPolygon:()=>$e,project:()=>fe,relaxMesh:()=>zt,reverseNormals:()=>He,simplify:()=>se,streamLinesExtractor:()=>Ue,triangleArea:()=>Qt,triangleNormal:()=>Vt,triangulate:()=>ie,vectorFromPointsToPlane:()=>Lt});var D=ft(48);class U{constructor(t,e){if(this.min_=[0,0,0],this.max_=[0,0,0],this.empty_=!1,this.reset(),t&&e)for(let n=0;n<3;++n){const a=Math.min(t[n],e[n]),d=Math.max(t[n],e[n]);Math.abs(d-a)>=1e-12?(D.vec.setCoord(this.min_,n,a),D.vec.setCoord(this.max_,n,d)):(D.vec.setCoord(this.min_,n,d),D.vec.setCoord(this.max_,n,d)),d<a&&(this.empty_=!0)}}reset(){this.empty_=!0,D.vec.set(this.min_,[1e32,1e32,1e32]),D.vec.set(this.max_,[-1e32,-1e32,-1e32])}get empty(){return this.empty_}get min(){return[...this.min_]}get max(){return[...this.max_]}get xLength(){return this.max_[0]-this.min_[0]}get yLength(){return this.max_[1]-this.min_[1]}get zLength(){return this.max_[2]-this.min_[2]}get sizes(){return[this.xLength,this.yLength,this.zLength]}get center(){let t=[...this.min_];return t=D.vec.scale(D.vec.add(t,this.max_),.5),t}get radius(){return D.vec.norm(D.vec.create(this.min_,this.max_))/2}scale(t){const e=D.vec.add(D.vec.scale(D.vec.create(this.center,this.min),t),this.center),n=D.vec.add(D.vec.scale(D.vec.create(this.center,this.max),t),this.center);D.vec.set(this.min_,e),D.vec.set(this.max_,n)}grow(t){this.empty_=!1;for(let e=0;e<3;++e)t[e]<this.min_[e]&&(this.min_[e]=t[e]),t[e]>this.max_[e]&&(this.max_[e]=t[e])}randPoint(){return[this.min_[0]+Math.random()*this.xLength,this.min_[1]+Math.random()*this.yLength,this.min_[2]+Math.random()*this.zLength]}contains(t,e=0){if(t instanceof U)return this.contains(t.min,e)===!0&&this.contains(t.max,e)===!0;const n=t;for(let a=0;a<3;++a)if(n[a]<this.min_[a]-e||n[a]>this.max_[a]+e)return!1;return!0}inside(t,e=0){return this.contains(t,e)}getIntersection(t){if(this.intersect(t)===!1)return new U;const e=[0,0,0],n=[0,0,0];for(let a=0;a<3;++a)this.min_[a]>=t.min_[a]?e[a]=this.min_[a]:e[a]=t.min_[a],this.max_[a]<=t.max_[a]?n[a]=this.max_[a]:n[a]=t.max_[a];return new U(e,n)}intersect(t){let e=!0;for(let n=0;n<3;++n)e=e&&this.min_[n]<=t.max_[n]&&t.min_[n]<=this.max_[n];return e}}function at(m,t=.01){let e=!1;const n=m.min,a=m.max;{const d=m.radius,p=m.max[0]-m.min[0],g=m.max[1]-m.min[1],_=m.max[2]-m.min[2],x=d*t,w=x/2;if(p<x){const v=(m.max[0]+m.min[0])/2;n[0]=v-w,a[0]=v+w,e=!0}if(g<x){const v=(m.max[1]+m.min[1])/2;n[1]=v-w,a[1]=v+w,e=!0}if(_<x){const v=(m.max[2]+m.min[2])/2;n[2]=v-w,a[2]=v+w,e=!0}}e===!0&&(m.reset(),m.grow(n),m.grow(a))}var R=ft(518);class ct{constructor(t=void 0){this.mat_=[1,0,0,0,1,0,0,0,1],t&&this.setNormal(t)}setBase(t,e,n){const a=vt(e,t,!0),d=vt(n,t,!0);return this.setNormal(D.vec.cross(a,d))}setNormal(t){let e=D.vec.clone(t);if(D.vec.norm(e)<1e-7)throw new Error("Cannot calculate element normal. Elt must have a very odd shape.");e=D.vec.normalize(e);let n=D.vec.cross([0,0,1],e);D.vec.norm(n)<1e-7&&(n=[0,1,0]),n=D.vec.normalize(n);let a=D.vec.cross(n,e);a=D.vec.normalize(a),this.mat_[0]=a[0],this.mat_[1]=n[0],this.mat_[2]=e[0],this.mat_[3]=a[1],this.mat_[4]=n[1],this.mat_[5]=e[1],this.mat_[6]=a[2],this.mat_[7]=n[2],this.mat_[8]=e[2]}get matrix(){return this.mat_}get dip(){return[this.mat_[0][0],this.mat_[1][0],this.mat_[2][0]]}get strike(){return[this.mat_[0][1],this.mat_[1][1],this.mat_[2][1]]}get normal(){return[this.mat_[0][2],this.mat_[1][2],this.mat_[2][2]]}toLocal(t){return(function(e,n){const a=n[0],d=n[1],p=n[2];return[e[0]*a+e[3]*d+e[6]*p,e[1]*a+e[4]*d+e[7]*p,e[2]*a+e[5]*d+e[8]*p]})(this.mat_,t)}toGlobal(t){return(function(e,n){const a=n[0],d=n[1],p=n[2];return[e[0]*a+e[1]*d+e[2]*p,e[3]*a+e[4]*d+e[5]*p,e[6]*a+e[7]*d+e[8]*p]})(this.mat_,t)}shearComponent(t){return D.vec.scale(D.vec.sub(t,this.normalComponent(t)),-1)}normalComponent(t){return D.vec.scale(this.normal,-D.vec.dot(t,this.normal))}}function O(m){if(m.length<3)throw new Error("Not enough points to fit a plane");const t=[0,0,0];for(let E=0;E<m.array.length;E+=3)t[0]+=m.array[E],t[1]+=m.array[E+1],t[2]+=m.array[E+2];const e=D.vec.scale(t,1/m.length);let n=0,a=0,d=0,p=0,g=0,_=0;for(let E=0;E<m.length;E+=3){const I=[m.array[E]-e[0],m.array[E+1]-e[1],m.array[E+2]-e[2]];n+=I[0]**2,a+=I[0]*I[1],d+=I[0]*I[2],p+=I[1]**2,g+=I[1]*I[2],_+=I[2]**2}const x=p*_-g*g,w=n*_-d*d,v=n*p-a*a,b=Math.max(x,w,v);if(b<=0)throw new Error("determlinant is <0");let N=[0,0,0];return N=b==x?[x,d*g-a*_,a*g-d*p]:b==w?[d*g-a*_,w,a*d-g*n]:[a*g-d*p,a*d-g*n,v],{point:e,normal:D.vec.normalize(N)}}function wt(m,t){if(R.Serie.isSerie(m)){const e=m;if(e.itemSize!==3)throw new Error("points must have itemSize = 3 (coordinates)");return e.map((n=>Tt(n,t)))}return Tt(m,t)}function Lt(m,t){if(R.Serie.isSerie(m)){const e=m;if(e.itemSize!==3)throw new Error("points must have itemSize = 3 (coordinates)");return e.map((n=>Ut(n,t)))}return Ut(m,t)}function fe(m,t){const e=(n,a)=>{const d=D.vec.dot(n,a);return[n[0]-d*a[0],n[1]-d*a[1]]};return R.Serie.isSerie(m)?m.map((n=>e(n,t.normal))):e(m,t.normal)}function Tt(m,t){const e=-D.vec.dot(t.normal,vt(t.point,m,!0))/D.vec.dot(t.normal,t.normal),n=D.vec.add(m,D.vec.scale(t.normal,e));return D.vec.norm(vt(m,n))}function Ut(m,t){const e=-D.vec.dot(t.normal,vt(t.point,m,!0))/D.vec.dot(t.normal,t.normal);return vt(m,D.vec.add(m,D.vec.scale(t.normal,e)))}function vt(m,t,e=!1){if(e){const n=t[0]-m[0],a=t[1]-m[1],d=t[2]-m[2],p=Math.sqrt(n**2+a**2+d**2);return[n/p,a/p,d/p]}return[t[0]-m[0],t[1]-m[1],t[2]-m[2]]}const me=Math.pow(2,-52),Wt=new Uint32Array(512);class Xt{static from(t,e=Me,n=pe){const a=t.length,d=new Float64Array(2*a);for(let p=0;p<a;p++){const g=t[p];d[2*p]=e(g),d[2*p+1]=n(g)}return new Xt(d)}constructor(t){this.trianglesLen=0;const e=t.length>>1;if(e>0&&typeof t[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=t;const n=Math.max(2*e-5,0);this._triangles=new Uint32Array(3*n),this._halfedges=new Int32Array(3*n),this._hashSize=Math.ceil(Math.sqrt(e)),this._hullPrev=new Uint32Array(e),this._hullNext=new Uint32Array(e),this._hullTri=new Uint32Array(e),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(e),this._dists=new Float64Array(e),this.update()}update(){const{coords:t,_hullPrev:e,_hullNext:n,_hullTri:a,_hullHash:d}=this,p=t.length>>1;let g=1/0,_=1/0,x=-1/0,w=-1/0;for(let V=0;V<p;V++){const K=t[2*V],X=t[2*V+1];K<g&&(g=K),X<_&&(_=X),K>x&&(x=K),X>w&&(w=X),this._ids[V]=V}const v=(g+x)/2,b=(_+w)/2;let N=1/0,E=0,I=0,T=0;for(let V=0;V<p;V++){const K=Gt(v,b,t[2*V],t[2*V+1]);K<N&&(E=V,N=K)}const B=t[2*E],F=t[2*E+1];N=1/0;for(let V=0;V<p;V++){if(V===E)continue;const K=Gt(B,F,t[2*V],t[2*V+1]);K<N&&K>0&&(I=V,N=K)}let j=t[2*I],H=t[2*I+1],nt=1/0;for(let V=0;V<p;V++){if(V===E||V===I)continue;const K=Ne(B,F,j,H,t[2*V],t[2*V+1]);K<nt&&(T=V,nt=K)}let it=t[2*T],Y=t[2*T+1];if(nt===1/0){for(let X=0;X<p;X++)this._dists[X]=t[2*X]-t[0]||t[2*X+1]-t[1];Ct(this._ids,this._dists,0,p-1);const V=new Uint32Array(p);let K=0;for(let X=0,Q=-1/0;X<p;X++){const ot=this._ids[X];this._dists[ot]>Q&&(V[K++]=ot,Q=this._dists[ot])}return this.hull=V.subarray(0,K),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(Jt(B,F,j,H,it,Y)){const V=I,K=j,X=H;I=T,j=it,H=Y,T=V,it=K,Y=X}const tt=(function(V,K,X,Q,ot,lt){const et=X-V,W=Q-K,$=ot-V,rt=lt-K,G=et*et+W*W,Rt=$*$+rt*rt,Je=.5/(et*rt-W*$);return{x:V+(rt*G-W*Rt)*Je,y:K+(et*Rt-$*G)*Je}})(B,F,j,H,it,Y);this._cx=tt.x,this._cy=tt.y;for(let V=0;V<p;V++)this._dists[V]=Gt(t[2*V],t[2*V+1],tt.x,tt.y);Ct(this._ids,this._dists,0,p-1),this._hullStart=E;let dt=3;n[E]=e[T]=I,n[I]=e[E]=T,n[T]=e[I]=E,a[E]=0,a[I]=1,a[T]=2,d.fill(-1),d[this._hashKey(B,F)]=E,d[this._hashKey(j,H)]=I,d[this._hashKey(it,Y)]=T,this.trianglesLen=0,this._addTriangle(E,I,T,-1,-1,-1);for(let V,K,X=0;X<this._ids.length;X++){const Q=this._ids[X],ot=t[2*Q],lt=t[2*Q+1];if(X>0&&Math.abs(ot-V)<=me&&Math.abs(lt-K)<=me||(V=ot,K=lt,Q===E||Q===I||Q===T))continue;let et=0;for(let Rt=0,Je=this._hashKey(ot,lt);Rt<this._hashSize&&(et=d[(Je+Rt)%this._hashSize],et===-1||et===n[et]);Rt++);et=e[et];let W,$=et;for(;W=n[$],!Jt(ot,lt,t[2*$],t[2*$+1],t[2*W],t[2*W+1]);)if($=W,$===et){$=-1;break}if($===-1)continue;let rt=this._addTriangle($,Q,n[$],-1,-1,a[$]);a[Q]=this._legalize(rt+2),a[$]=rt,dt++;let G=n[$];for(;W=n[G],Jt(ot,lt,t[2*G],t[2*G+1],t[2*W],t[2*W+1]);)rt=this._addTriangle(G,Q,W,a[Q],-1,a[G]),a[Q]=this._legalize(rt+2),n[G]=G,dt--,G=W;if($===et)for(;W=e[$],Jt(ot,lt,t[2*W],t[2*W+1],t[2*$],t[2*$+1]);)rt=this._addTriangle(W,Q,$,-1,a[$],a[W]),this._legalize(rt+2),a[W]=rt,n[$]=$,dt--,$=W;this._hullStart=e[Q]=$,n[$]=e[G]=Q,n[Q]=G,d[this._hashKey(ot,lt)]=Q,d[this._hashKey(t[2*$],t[2*$+1])]=$}this.hull=new Uint32Array(dt);for(let V=0,K=this._hullStart;V<dt;V++)this.hull[V]=K,K=n[K];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,e){return Math.floor((function(n,a){const d=n/(Math.abs(n)+Math.abs(a));return(a>0?3-d:1+d)/4})(t-this._cx,e-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:e,_halfedges:n,coords:a}=this;let d=0,p=0;for(;;){const g=n[t],_=t-t%3;if(p=_+(t+2)%3,g===-1){if(d===0)break;t=Wt[--d];continue}const x=g-g%3,w=_+(t+1)%3,v=x+(g+2)%3,b=e[p],N=e[t],E=e[w],I=e[v];if(be(a[2*b],a[2*b+1],a[2*N],a[2*N+1],a[2*E],a[2*E+1],a[2*I],a[2*I+1])){e[t]=I,e[g]=b;const T=n[v];if(T===-1){let F=this._hullStart;do{if(this._hullTri[F]===v){this._hullTri[F]=t;break}F=this._hullPrev[F]}while(F!==this._hullStart)}this._link(t,T),this._link(g,n[p]),this._link(p,v);const B=x+(g+1)%3;d<Wt.length&&(Wt[d++]=B)}else{if(d===0)break;t=Wt[--d]}}return p}_link(t,e){this._halfedges[t]=e,e!==-1&&(this._halfedges[e]=t)}_addTriangle(t,e,n,a,d,p){const g=this.trianglesLen;return this._triangles[g]=t,this._triangles[g+1]=e,this._triangles[g+2]=n,this._link(g,a),this._link(g+1,d),this._link(g+2,p),this.trianglesLen+=3,g}}function Gt(m,t,e,n){const a=m-e,d=t-n;return a*a+d*d}function ee(m,t,e,n,a,d){const p=(n-t)*(a-m),g=(e-m)*(d-t);return Math.abs(p-g)>=33306690738754716e-32*Math.abs(p+g)?p-g:0}function Jt(m,t,e,n,a,d){return(ee(a,d,m,t,e,n)||ee(m,t,e,n,a,d)||ee(e,n,a,d,m,t))<0}function be(m,t,e,n,a,d,p,g){const _=m-p,x=t-g,w=e-p,v=n-g,b=a-p,N=d-g,E=w*w+v*v,I=b*b+N*N;return _*(v*I-E*N)-x*(w*I-E*b)+(_*_+x*x)*(w*N-v*b)<0}function Ne(m,t,e,n,a,d){const p=e-m,g=n-t,_=a-m,x=d-t,w=p*p+g*g,v=_*_+x*x,b=.5/(p*x-g*_),N=(x*w-g*v)*b,E=(p*v-_*w)*b;return N*N+E*E}function Ct(m,t,e,n){if(n-e<=20)for(let a=e+1;a<=n;a++){const d=m[a],p=t[d];let g=a-1;for(;g>=e&&t[m[g]]>p;)m[g+1]=m[g--];m[g+1]=d}else{let a=e+1,d=n;bt(m,e+n>>1,a),t[m[e]]>t[m[n]]&&bt(m,e,n),t[m[a]]>t[m[n]]&&bt(m,a,n),t[m[e]]>t[m[a]]&&bt(m,e,a);const p=m[a],g=t[p];for(;;){do a++;while(t[m[a]]<g);do d--;while(t[m[d]]>g);if(d<a)break;bt(m,a,d)}m[e+1]=m[d],m[d]=p,n-a+1>=d-e?(Ct(m,t,a,n),Ct(m,t,e,d-1)):(Ct(m,t,e,d-1),Ct(m,t,a,n))}}function bt(m,t,e){const n=m[t];m[t]=m[e],m[e]=n}function Me(m){return m[0]}function pe(m){return m[1]}function ie(m,t=[0,0,1]){let e;if(m.itemSize===2)e=new Xt(m.array);else{const a=m.map((d=>fe(d,{normal:t})));e=new Xt(a.array)}const n=R.Serie.create({array:e.triangles,itemSize:3});return R.DataFrame.create({series:{indices:n,positions:m}})}function kt({a:m,b:t,nbRings:e=4,density:n=8,center:a=[0,0,0]}){const d=(w,v)=>g.push(w+a[0],v+a[1],a[2]),p=(w,v,b)=>{for(let N=0;N<b;++N){const E=2*Math.PI*N/(b-1),I=w*Math.cos(E)/2,T=v*Math.sin(E)/2;d(I,T)}},g=[],_=m/e,x=t/e;for(let w=1;w<=e;++w)p(_*w,x*w,n*w);return d(0,0),ie(R.Serie.create({array:g,itemSize:3}))}function re({a:m,b:t,na:e,nb:n,center:a=[0,0,0]}){const d=[],p=1/(e-1),g=1/(n-1);for(let w=0;w<e;++w)for(let v=0;v<n;++v)_=m*w*p,x=t*v*g,d.push(_+a[0]-m/2,x+a[1]-t/2,a[2]);var _,x;return ie(R.Serie.create({array:d,itemSize:3}))}function se(m,t=1,e=!1){const n=t!==void 0?t*t:1;return(function(a,d){const p=a.length,g=new(typeof Uint8Array<"u"?Uint8Array:Array)(p),_=[],x=[];let w,v,b,N,E=0,I=p-1;for(g[E]=g[I]=1;I;){for(v=0,w=E+1;w<I;w++)b=Ie(a.itemAt(w),a.itemAt(E),a.itemAt(I)),b>v&&(N=w,v=b);v>d&&(g[N]=1,_.push(E,N,N,I)),I=_.pop(),E=_.pop()}for(w=0;w<p;w++)g[w]&&x.push(a[w]);const T=a.itemSize,B=a.image(a.length/T,T);return(0,R.copy)(x,B)})(e?m:(function(a,d){let p=a.itemAt(0);const g=[...p];let _;const x=a.itemSize;for(let v=1,b=a.count;v<b;++v)_=a.itemAt(v),ne(_,p)>d&&(g.push(..._),p=_);p!==_&&g.push(..._);const w=a.image(a.length/x,x);return(0,R.copy)(g,w)})(m,n),n)}const ne=(m,t)=>D.vec.norm2(D.vec.sub(m,t));function Ie(m,t,e){if(m.length===2){let x=t[0],w=t[1],v=e[0]-x,b=e[1]-w;if(v!==0||b!==0){const N=((m[0]-x)*v+(m[1]-w)*b)/(v*v+b*b);N>1?(x=e[0],w=e[1]):N>0&&(x+=v*N,w+=b*N)}return v=m[0]-x,b=m[1]-w,v*v+b*b}let n=t[0],a=t[1],d=t[2],p=e[0]-n,g=e[1]-a,_=e[2]-d;if(p!==0||g!==0||_!==0){const x=((m[0]-n)*p+(m[1]-a)*g+(m[2]-d)*_)/(p*p+g*g+_*_);x>1?(n=e[0],a=e[1],d=e[2]):x>0&&(n+=p*x,a+=g*x,d+=_*x)}return p=m[0]-n,g=m[1]-a,_=m[2]-d,p*p+g*g+_*_}function qe(m,{shared:t=!0,typed:e=!0}={}){if(m<1)throw new Error("Subdivision must be > 0");const n=(1+Math.sqrt(5))/2,a=new Array,d=new Array;let p=0;const g=[[1,n,0],[-1,n,0],[1,-n,0],[-1,-n,0],[0,1,n],[0,-1,n],[0,1,-n],[0,-1,-n],[n,0,1],[-n,0,1],[n,0,-1],[-n,0,-1]],_=[[0,1,4],[1,9,4],[4,9,5],[5,9,3],[2,3,7],[3,2,5],[7,10,2],[0,8,10],[0,4,8],[8,2,10],[8,4,5],[8,5,2],[1,0,6],[11,1,6],[3,9,11],[6,10,7],[3,11,7],[11,6,7],[6,0,10],[9,1,11]].map((b=>b.map((N=>g[N])))),x=([b,N,E])=>{const I=3/Math.sqrt(b**2+N**2+E**2);return[I*b,I*N,I*E]},w=([b,N,E],[I,T,B],F)=>[b+F*(I-b),N+F*(T-N),E+F*(B-E)],v=(...b)=>b.forEach((N=>{a.push(N[0],N[1],N[2]),d.push(p++)}));for(const[b,N,E]of _){let I,T,B=w(b,N,1/m),F=w(b,E,1/m);v(x(b),x(B),x(F));for(let j=1;j<m;++j){I=B,B=w(b,N,(j+1)/m),T=F,F=w(b,E,(j+1)/m);for(let H=0;H<=j;++H)v(x(w(I,T,H/j)),x(w(B,F,H/(j+1))),x(w(B,F,(H+1)/(j+1))));for(let H=0;H<j;++H)v(x(w(I,T,H/j)),x(w(B,F,(H+1)/(j+1))),x(w(I,T,(H+1)/j)))}}return e?{positions:(0,R.createTyped)(Float32Array,a,t),indices:(0,R.createTyped)(Int16Array,d,t)}:{positions:a,indices:d}}class k{constructor(t,e,n,a,d=1e-7){this._origin=[0,0],this._n=[0,0],this._dx=0,this._dy=0,this._n=[n,a],this._dx=(e[0]-t[0]+2*d)/(n-1),this._dy=(e[1]-t[1]+2*d)/(a-1),this._origin=[t[0]-d,t[1]-d]}get count(){return this._n[0]*this._n[1]}get nx(){return this._n[0]}get ny(){return this._n[1]}get dx(){return this._dx}get dy(){return this._dy}get origin(){return this._origin}get xLength(){return this._n[0]*this._dx}get yLength(){return this._n[1]*this._dy}getIJ(t){const e=t[0]-this._origin[0],n=e/this._dx;if(e<0||n>this._n[0])return{ok:!1};const a=Math.trunc(n),d=t[1]-this._origin[1],p=d/this._dy;return d<0||p>this._n[1]?{ok:!1}:{ok:!0,ij:[a,Math.trunc(p)]}}flatIndex(t,e){return t+e*this._n[0]}flatIndices(t){const e=this.candidate(t);if(e===void 0)return;const n=this.flatIndex(e[0],e[1]),a=this.flatIndex(e[0],e[1]+1);return[n,a,n+1,a+1]}positionAt(t,e){return[this._origin[0]+t*this._dx,this._origin[1]+e*this._dy]}candidate(t){const{ok:e,ij:n}=this.getIJ(t);if(e)return n}interpolate(t,e){const n=this.getIJ(t);if(n.ok){const a=n.ij[0],d=n.ij[1],p=this.positionAt(a,d),g=this.positionAt(a+1,d+1),_=this.flatIndices(t).map((x=>e.itemAt(x)));return Array.isArray(_[0])?_[0].map(((x,w)=>(0,D.biLerp)(t,p,g,x,_[1][w],_[2][w],_[3][w]))):(0,D.biLerp)(t,p,g,_[0],_[1],_[2],_[3])}}forEach(t){let e=0;for(let n=0;n<this._n[0];++n)for(let a=0;a<this._n[1];++a){const d=this.positionAt(n,a);t(d[0],d[1],n,a,e++)}}map(t){const e=new Array(this.count);let n=0;for(let a=0;a<this._n[0];++a)for(let d=0;d<this._n[1];++d){const p=this.positionAt(a,d);e[n]=t(p[0],p[1],a,d,n++)}return e}}class A{constructor(t,e,n,a,d,p=1e-7){this._origin=[0,0,0],this._n=[0,0,0],this._dx=0,this._dy=0,this._dz=0,this._n=[n,a,d],this._dx=(e[0]-t[0]+2*p)/(n-1),this._dy=(e[1]-t[1]+2*p)/(a-1),this._dz=(e[2]-t[2]+2*p)/(d-1),this._origin=[t[0]-p,t[1]-p,t[2]-p]}get count(){return this._n[0]*this._n[1]*this._n[2]}get nx(){return this._n[0]}get ny(){return this._n[1]}get nz(){return this._n[2]}get dx(){return this._dx}get dy(){return this._dy}get dz(){return this._dz}get origin(){return this._origin}get xLength(){return this._n[0]*this._dx}get yLength(){return this._n[1]*this._dy}get zLength(){return this._n[2]*this._dz}getIJK(t){const e=t[0]-this._origin[0];if(e<0)return{ok:!1};const n=t[1]-this._origin[1];if(n<0)return{ok:!1};const a=t[2]-this._origin[2];if(a<0)return{ok:!1};const d=e/this._dx;if(d>this._n[0])return{ok:!1};const p=n/this._dy;return p>this._n[1]||a/this._dz>this._n[2]?{ok:!1}:{ok:!0,ijk:[Math.trunc(d),Math.trunc(p),Math.trunc(p)]}}flatIndex(t,e,n){return t+this._n[0]*e+this._n[0]*this._n[1]*n}flatIndices(t){const e=this.candidate(t);if(e===void 0)return;const n=this.flatIndex(e[0],e[1],e[2]),a=this.flatIndex(e[0],e[1]+1,e[2]),d=this.flatIndex(e[0],e[1],e[2]+1),p=this.flatIndex(e[0],e[1]+1,e[2]+1);return[n,n+1,a,a+1,d,d+1,p,p+1]}positionAt(t,e,n){return[this._origin[0]+t*this._dx,this._origin[1]+e*this._dy,this._origin[2]+n*this._dz]}candidate(t){const{ok:e,ijk:n}=this.getIJK(t);if(e)return n}interpolate(t,e){const n=this.getIJK(t);if(n.ok){const a=n.ijk[0],d=n.ijk[1],p=n.ijk[2],g=this.positionAt(a,d,p),_=this.positionAt(a+1,d+1,p+1),x=new Array(8);x[0]=this.flatIndex(a,d,p),x[1]=this.flatIndex(a,d,p+1),x[2]=this.flatIndex(a,d+1,p),x[3]=this.flatIndex(a,d+1,p+1),x[4]=this.flatIndex(a+1,d,p),x[5]=this.flatIndex(a+1,d,p+1),x[6]=this.flatIndex(a+1,d+1,p),x[7]=this.flatIndex(a+1,d+1,p+1);const w=x.map((v=>e.itemAt(v)));return Array.isArray(w[0])?w[0].map(((v,b)=>(0,D.triLerp)(t,g,_,v,w[1][b],w[2][b],w[3][b],w[4][b],w[5][b],w[6][b],w[7][b]))):(0,D.triLerp)(t,g,_,w[0],w[1],w[2],w[3],w[4],w[5],w[6],w[7])}}forEach(t){let e=0;for(let n=0;n<this._n[0];++n)for(let a=0;a<this._n[1];++a)for(let d=0;d<this._n[2];++d){const p=this.positionAt(n,a,d);t(p[0],p[1],p[2],n,a,d,e++)}}map(t){const e=new Array(this.count);let n=0;for(let a=0;a<this._n[0];++a)for(let d=0;d<this._n[1];++d)for(let p=0;p<this._n[2];++p){const g=this.positionAt(a,d,p);e[n]=t(g[0],g[1],g[2],a,d,p,n++)}return e}}function z({positions:m,indices:t,dims:e=[20,20],eps:n=.01}){const a=(0,D.minMax)(m),d=[];d.push((a[3]-a[0]+2*n)/e[0]),d.push((a[4]-a[1]+2*n)/e[1]);const p=[a[0]-n,a[1]-n],g=new M;return g.set(p,d[0],d[1],e[0],e[1]),t.forEach(((_,x)=>{const w=[],v=[];_.forEach((b=>{const N=m.itemAt(b);w.push(N[0]),v.push(N[1])})),g.insert(new C([Math.min(...w),Math.max(...w)],[Math.min(...v),Math.max(...v)],x))})),g}class M{constructor(){this.origin_=[0,0],this.dx_=0,this.dy_=0,this.nx_=0,this.ny_=0}set(t,e,n,a,d){this.origin_=[...t],this.dx_=e,this.dy_=n,this.nx_=a,this.ny_=d,this.cells_=Array(this.nx_*this.ny_).fill(void 0).map((()=>new L))}get nx(){return this.nx_}get ny(){return this.ny_}get dx(){return this.dx_}get dy(){return this.dy_}get origin(){return this.origin_}get bbox(){return{x:this.origin_[0],y:this.origin_[1],width:this.dx_*this.nx_,height:this.dy_*this.ny_}}forAllPoints(t){for(let e=0;e<this.nx_;++e)for(let n=0;n<this.ny_;++n){const a=this.getFlatIndex(e,n);t(this.cells_[a].objects,e,n,this.getCoordinates(e,n))}}insert(t){const e=this.getIJ(t.min);if(!e.ok)return!1;const n=e.ij,a=this.getIJ(t.max);if(!a.ok)return!1;const d=a.ij,p=Math.min(n[0],d[0]),g=Math.max(n[0],d[0]),_=Math.min(n[1],d[1]),x=Math.max(n[1],d[1]);for(let w=p;w<=g;++w)for(let v=_;v<=x;++v){const b=this.getFlatIndex(w,v);this.cells_[b].objects.push(t)}return!0}candidatesFromIJ(t,e){const n=this.getFlatIndex(t,e);return this.cells_[n].objects}candidates(t){const{ok:e,ij:n}=this.getIJ(t);if(!e)return[];const a=this.getFlatIndex(n[0],n[1]);return this.cells_[a].objects}getIJ(t){const e=t[0]-this.origin_[0];if(e<0)return P;const n=t[1]-this.origin_[1];if(n<0)return P;const a=e/this.dx_;if(a>this.nx_)return P;const d=n/this.dy_;return d>this.ny_?P:{ok:!0,ij:[Math.floor(a),Math.floor(d)]}}getCoordinates(t,e){return[this.origin_[0]+t*this.dx_,this.origin_[1]+e*this.dy_]}getFlatIndex(t,e){return this.nx_*e+t}}const P={ok:!1};class C{constructor(t,e,n){this.min=[0,0],this.max=[0,0],this.min=[t[0],e[0]],this.max=[t[1],e[1]],this.obj=n}contains(t,e){return t>=this.min[0]&&t<=this.max[0]&&e>=this.min[1]&&e<=this.max[1]}}class L{constructor(){this.objects=[]}}function zt(m,t,e=100,n=.1){const a=Pt.create(m,t);let d=0;a.forEachFace((g=>d+=g.area)),d/=a.nbFacets;const p=Math.sqrt(4*d/Math.sqrt(3));for(let g=0;g<e;++g)a.forEachNode((_=>{if(_.isOnBorder===!1){let x=[0,0,0];he(_,(w=>{const v=D.vec.create(_.pos,w.pos),b=D.vec.norm(v);v[0]/=b,v[1]/=b,x=D.vec.add(x,D.vec.scale(v,b-p))})),_.setPos(_.pos[0]+x[0]*n,_.pos[1]+x[1]*n,x[2])}}));return a.nodesAsSerie}class xt{constructor(t,e){if(this.grid=t,this.values=e,this.XYZ_=!0,this.bounds_=[],this.grid.sizes.length!==3)throw new Error("sizes must be an array of length 3");const n=t.sizes.reduce(((a,d)=>a*d),1);if(n!==e.length)throw new Error(`number of points (${n}) must equal the number of values (${e.length})`)}get valid(){return this.grid!==void 0&&this.values!==void 0}set xyzOrder(t){this.XYZ_=t}get xyzOrder(){return this.XYZ_}run(t,e){if(!this.valid)return{positions:[],indices:[]};this.bounds_=e===void 0?[Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY]:e;const n=new Array(12),a=[],d=[];let p,g,_;this.XYZ_===!1?(p=this.grid.sizes[0],g=this.grid.sizes[1],_=this.grid.sizes[2]):(p=this.grid.sizes[2],g=this.grid.sizes[1],_=this.grid.sizes[0]);const x=g*_;let w=0;for(let v=0;v<p-1;v++)for(let b=0;b<g-1;b++)for(let N=0;N<_-1;N++){let E,I,T,B,F,j,H,nt,it,Y,tt;this.XYZ_===!1?(E=v,I=b,T=N,B=T+_*I+x*E,F=B+x,j=B+_,H=j+x,nt=B+1,it=F+1,Y=j+1,tt=H+1):(E=N,I=b,T=v,B=E+_*I+x*T,F=B+1,j=B+_,H=j+1,nt=B+x,it=F+x,Y=j+x,tt=H+x);const dt=this.values[B],V=this.values[F],K=this.values[j],X=this.values[H],Q=this.values[nt],ot=this.values[it],lt=this.values[Y],et=this.values[tt],W=[dt,V,K,X,Q,ot,lt,et];if(this._ok(W)===!1)continue;let $=0;dt<t&&($|=1),V<t&&($|=2),K<t&&($|=8),X<t&&($|=4),Q<t&&($|=16),ot<t&&($|=32),lt<t&&($|=128),et<t&&($|=64);const rt=Ot[$];if(rt===0)continue;let G=.5;1&rt&&(G=(t-dt)/(V-dt),n[0]=this.lerp(B,F,G)),2&rt&&(G=(t-V)/(X-V),n[1]=this.lerp(F,H,G)),4&rt&&(G=(t-K)/(X-K),n[2]=this.lerp(j,H,G)),8&rt&&(G=(t-dt)/(K-dt),n[3]=this.lerp(B,j,G)),16&rt&&(G=(t-Q)/(ot-Q),n[4]=this.lerp(nt,it,G)),32&rt&&(G=(t-ot)/(et-ot),n[5]=this.lerp(it,tt,G)),64&rt&&(G=(t-lt)/(et-lt),n[6]=this.lerp(Y,tt,G)),128&rt&&(G=(t-Q)/(lt-Q),n[7]=this.lerp(nt,Y,G)),256&rt&&(G=(t-dt)/(Q-dt),n[8]=this.lerp(B,nt,G)),512&rt&&(G=(t-V)/(ot-V),n[9]=this.lerp(F,it,G)),1024&rt&&(G=(t-X)/(et-X),n[10]=this.lerp(H,tt,G)),2048&rt&&(G=(t-K)/(lt-K),n[11]=this.lerp(j,Y,G));let Rt=0;for($<<=4;ge[$+Rt]!==-1;){const Je=ge[$+Rt],vi=ge[$+Rt+1],Si=ge[$+Rt+2];a.push(...n[Je],...n[vi],...n[Si]),d.push(w,w+1,w+2),w+=3,Rt+=3}}return{positions:a,indices:d}}_in(t){return t>=this.bounds_[0]&&t<=this.bounds_[1]}_ok(t){let e=!0;return t.forEach((n=>{e=e&&this._in(n)})),e}unflat(t){const e=this.grid.sizes[1],n=this.grid.sizes[2],a=t/e/n,d=Math.trunc(a),p=e*n*(a-d)/n,g=Math.trunc(p),_=n*(p-g);return[Math.round(d),Math.round(g),Math.round(_)]}lerp(t,e,n){const a=this.unflat(t),d=this.grid.pos(a[0],a[1],a[2]),p=this.unflat(e),g=this.grid.pos(p[0],p[1],p[2]);return d[0]+=(g[0]-d[0])*n,d[1]+=(g[1]-d[1])*n,d[2]+=(g[2]-d[2])*n,d}}const Ot=new Int32Array([0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0]),ge=new Int32Array([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,9,8,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,2,10,0,2,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,8,3,2,10,8,10,9,8,-1,-1,-1,-1,-1,-1,-1,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,8,11,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,11,2,1,9,11,9,8,11,-1,-1,-1,-1,-1,-1,-1,3,10,1,11,10,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,10,1,0,8,10,8,11,10,-1,-1,-1,-1,-1,-1,-1,3,9,0,3,11,9,11,10,9,-1,-1,-1,-1,-1,-1,-1,9,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,7,3,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,1,9,4,7,1,7,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,4,7,3,0,4,1,2,10,-1,-1,-1,-1,-1,-1,-1,9,2,10,9,0,2,8,4,7,-1,-1,-1,-1,-1,-1,-1,2,10,9,2,9,7,2,7,3,7,9,4,-1,-1,-1,-1,8,4,7,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,4,7,11,2,4,2,0,4,-1,-1,-1,-1,-1,-1,-1,9,0,1,8,4,7,2,3,11,-1,-1,-1,-1,-1,-1,-1,4,7,11,9,4,11,9,11,2,9,2,1,-1,-1,-1,-1,3,10,1,3,11,10,7,8,4,-1,-1,-1,-1,-1,-1,-1,1,11,10,1,4,11,1,0,4,7,11,4,-1,-1,-1,-1,4,7,8,9,0,11,9,11,10,11,0,3,-1,-1,-1,-1,4,7,11,4,11,9,9,11,10,-1,-1,-1,-1,-1,-1,-1,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,5,4,1,5,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,5,4,8,3,5,3,1,5,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,10,4,9,5,-1,-1,-1,-1,-1,-1,-1,5,2,10,5,4,2,4,0,2,-1,-1,-1,-1,-1,-1,-1,2,10,5,3,2,5,3,5,4,3,4,8,-1,-1,-1,-1,9,5,4,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,0,8,11,4,9,5,-1,-1,-1,-1,-1,-1,-1,0,5,4,0,1,5,2,3,11,-1,-1,-1,-1,-1,-1,-1,2,1,5,2,5,8,2,8,11,4,8,5,-1,-1,-1,-1,10,3,11,10,1,3,9,5,4,-1,-1,-1,-1,-1,-1,-1,4,9,5,0,8,1,8,10,1,8,11,10,-1,-1,-1,-1,5,4,0,5,0,11,5,11,10,11,0,3,-1,-1,-1,-1,5,4,8,5,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,9,7,8,5,7,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,3,0,9,5,3,5,7,3,-1,-1,-1,-1,-1,-1,-1,0,7,8,0,1,7,1,5,7,-1,-1,-1,-1,-1,-1,-1,1,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,7,8,9,5,7,10,1,2,-1,-1,-1,-1,-1,-1,-1,10,1,2,9,5,0,5,3,0,5,7,3,-1,-1,-1,-1,8,0,2,8,2,5,8,5,7,10,5,2,-1,-1,-1,-1,2,10,5,2,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,7,9,5,7,8,9,3,11,2,-1,-1,-1,-1,-1,-1,-1,9,5,7,9,7,2,9,2,0,2,7,11,-1,-1,-1,-1,2,3,11,0,1,8,1,7,8,1,5,7,-1,-1,-1,-1,11,2,1,11,1,7,7,1,5,-1,-1,-1,-1,-1,-1,-1,9,5,8,8,5,7,10,1,3,10,3,11,-1,-1,-1,-1,5,7,0,5,0,9,7,11,0,1,0,10,11,10,0,-1,11,10,0,11,0,3,10,5,0,8,0,7,5,7,0,-1,11,10,5,7,11,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,0,1,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,1,9,8,5,10,6,-1,-1,-1,-1,-1,-1,-1,1,6,5,2,6,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,6,5,1,2,6,3,0,8,-1,-1,-1,-1,-1,-1,-1,9,6,5,9,0,6,0,2,6,-1,-1,-1,-1,-1,-1,-1,5,9,8,5,8,2,5,2,6,3,2,8,-1,-1,-1,-1,2,3,11,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,0,8,11,2,0,10,6,5,-1,-1,-1,-1,-1,-1,-1,0,1,9,2,3,11,5,10,6,-1,-1,-1,-1,-1,-1,-1,5,10,6,1,9,2,9,11,2,9,8,11,-1,-1,-1,-1,6,3,11,6,5,3,5,1,3,-1,-1,-1,-1,-1,-1,-1,0,8,11,0,11,5,0,5,1,5,11,6,-1,-1,-1,-1,3,11,6,0,3,6,0,6,5,0,5,9,-1,-1,-1,-1,6,5,9,6,9,11,11,9,8,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,4,7,3,6,5,10,-1,-1,-1,-1,-1,-1,-1,1,9,0,5,10,6,8,4,7,-1,-1,-1,-1,-1,-1,-1,10,6,5,1,9,7,1,7,3,7,9,4,-1,-1,-1,-1,6,1,2,6,5,1,4,7,8,-1,-1,-1,-1,-1,-1,-1,1,2,5,5,2,6,3,0,4,3,4,7,-1,-1,-1,-1,8,4,7,9,0,5,0,6,5,0,2,6,-1,-1,-1,-1,7,3,9,7,9,4,3,2,9,5,9,6,2,6,9,-1,3,11,2,7,8,4,10,6,5,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,2,4,2,0,2,7,11,-1,-1,-1,-1,0,1,9,4,7,8,2,3,11,5,10,6,-1,-1,-1,-1,9,2,1,9,11,2,9,4,11,7,11,4,5,10,6,-1,8,4,7,3,11,5,3,5,1,5,11,6,-1,-1,-1,-1,5,1,11,5,11,6,1,0,11,7,11,4,0,4,11,-1,0,5,9,0,6,5,0,3,6,11,6,3,8,4,7,-1,6,5,9,6,9,11,4,7,9,7,11,9,-1,-1,-1,-1,10,4,9,6,4,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,10,6,4,9,10,0,8,3,-1,-1,-1,-1,-1,-1,-1,10,0,1,10,6,0,6,4,0,-1,-1,-1,-1,-1,-1,-1,8,3,1,8,1,6,8,6,4,6,1,10,-1,-1,-1,-1,1,4,9,1,2,4,2,6,4,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,9,2,4,9,2,6,4,-1,-1,-1,-1,0,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,3,2,8,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,10,4,9,10,6,4,11,2,3,-1,-1,-1,-1,-1,-1,-1,0,8,2,2,8,11,4,9,10,4,10,6,-1,-1,-1,-1,3,11,2,0,1,6,0,6,4,6,1,10,-1,-1,-1,-1,6,4,1,6,1,10,4,8,1,2,1,11,8,11,1,-1,9,6,4,9,3,6,9,1,3,11,6,3,-1,-1,-1,-1,8,11,1,8,1,0,11,6,1,9,1,4,6,4,1,-1,3,11,6,3,6,0,0,6,4,-1,-1,-1,-1,-1,-1,-1,6,4,8,11,6,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,10,6,7,8,10,8,9,10,-1,-1,-1,-1,-1,-1,-1,0,7,3,0,10,7,0,9,10,6,7,10,-1,-1,-1,-1,10,6,7,1,10,7,1,7,8,1,8,0,-1,-1,-1,-1,10,6,7,10,7,1,1,7,3,-1,-1,-1,-1,-1,-1,-1,1,2,6,1,6,8,1,8,9,8,6,7,-1,-1,-1,-1,2,6,9,2,9,1,6,7,9,0,9,3,7,3,9,-1,7,8,0,7,0,6,6,0,2,-1,-1,-1,-1,-1,-1,-1,7,3,2,6,7,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,11,10,6,8,10,8,9,8,6,7,-1,-1,-1,-1,2,0,7,2,7,11,0,9,7,6,7,10,9,10,7,-1,1,8,0,1,7,8,1,10,7,6,7,10,2,3,11,-1,11,2,1,11,1,7,10,6,1,6,7,1,-1,-1,-1,-1,8,9,6,8,6,7,9,1,6,11,6,3,1,3,6,-1,0,9,1,11,6,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,8,0,7,0,6,3,11,0,11,6,0,-1,-1,-1,-1,7,11,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,1,9,8,3,1,11,7,6,-1,-1,-1,-1,-1,-1,-1,10,1,2,6,11,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,8,6,11,7,-1,-1,-1,-1,-1,-1,-1,2,9,0,2,10,9,6,11,7,-1,-1,-1,-1,-1,-1,-1,6,11,7,2,10,3,10,8,3,10,9,8,-1,-1,-1,-1,7,2,3,6,2,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,0,8,7,6,0,6,2,0,-1,-1,-1,-1,-1,-1,-1,2,7,6,2,3,7,0,1,9,-1,-1,-1,-1,-1,-1,-1,1,6,2,1,8,6,1,9,8,8,7,6,-1,-1,-1,-1,10,7,6,10,1,7,1,3,7,-1,-1,-1,-1,-1,-1,-1,10,7,6,1,7,10,1,8,7,1,0,8,-1,-1,-1,-1,0,3,7,0,7,10,0,10,9,6,10,7,-1,-1,-1,-1,7,6,10,7,10,8,8,10,9,-1,-1,-1,-1,-1,-1,-1,6,8,4,11,8,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,6,11,3,0,6,0,4,6,-1,-1,-1,-1,-1,-1,-1,8,6,11,8,4,6,9,0,1,-1,-1,-1,-1,-1,-1,-1,9,4,6,9,6,3,9,3,1,11,3,6,-1,-1,-1,-1,6,8,4,6,11,8,2,10,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,11,0,6,11,0,4,6,-1,-1,-1,-1,4,11,8,4,6,11,0,2,9,2,10,9,-1,-1,-1,-1,10,9,3,10,3,2,9,4,3,11,3,6,4,6,3,-1,8,2,3,8,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,0,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,4,2,4,6,4,3,8,-1,-1,-1,-1,1,9,4,1,4,2,2,4,6,-1,-1,-1,-1,-1,-1,-1,8,1,3,8,6,1,8,4,6,6,10,1,-1,-1,-1,-1,10,1,0,10,0,6,6,0,4,-1,-1,-1,-1,-1,-1,-1,4,6,3,4,3,8,6,10,3,0,3,9,10,9,3,-1,10,9,4,6,10,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,5,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,5,11,7,6,-1,-1,-1,-1,-1,-1,-1,5,0,1,5,4,0,7,6,11,-1,-1,-1,-1,-1,-1,-1,11,7,6,8,3,4,3,5,4,3,1,5,-1,-1,-1,-1,9,5,4,10,1,2,7,6,11,-1,-1,-1,-1,-1,-1,-1,6,11,7,1,2,10,0,8,3,4,9,5,-1,-1,-1,-1,7,6,11,5,4,10,4,2,10,4,0,2,-1,-1,-1,-1,3,4,8,3,5,4,3,2,5,10,5,2,11,7,6,-1,7,2,3,7,6,2,5,4,9,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,6,0,6,2,6,8,7,-1,-1,-1,-1,3,6,2,3,7,6,1,5,0,5,4,0,-1,-1,-1,-1,6,2,8,6,8,7,2,1,8,4,8,5,1,5,8,-1,9,5,4,10,1,6,1,7,6,1,3,7,-1,-1,-1,-1,1,6,10,1,7,6,1,0,7,8,7,0,9,5,4,-1,4,0,10,4,10,5,0,3,10,6,10,7,3,7,10,-1,7,6,10,7,10,8,5,4,10,4,8,10,-1,-1,-1,-1,6,9,5,6,11,9,11,8,9,-1,-1,-1,-1,-1,-1,-1,3,6,11,0,6,3,0,5,6,0,9,5,-1,-1,-1,-1,0,11,8,0,5,11,0,1,5,5,6,11,-1,-1,-1,-1,6,11,3,6,3,5,5,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,11,9,11,8,11,5,6,-1,-1,-1,-1,0,11,3,0,6,11,0,9,6,5,6,9,1,2,10,-1,11,8,5,11,5,6,8,0,5,10,5,2,0,2,5,-1,6,11,3,6,3,5,2,10,3,10,5,3,-1,-1,-1,-1,5,8,9,5,2,8,5,6,2,3,8,2,-1,-1,-1,-1,9,5,6,9,6,0,0,6,2,-1,-1,-1,-1,-1,-1,-1,1,5,8,1,8,0,5,6,8,3,8,2,6,2,8,-1,1,5,6,2,1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,6,1,6,10,3,8,6,5,6,9,8,9,6,-1,10,1,0,10,0,6,9,5,0,5,6,0,-1,-1,-1,-1,0,3,8,5,6,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,5,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,7,5,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,11,7,5,8,3,0,-1,-1,-1,-1,-1,-1,-1,5,11,7,5,10,11,1,9,0,-1,-1,-1,-1,-1,-1,-1,10,7,5,10,11,7,9,8,1,8,3,1,-1,-1,-1,-1,11,1,2,11,7,1,7,5,1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,7,1,7,5,7,2,11,-1,-1,-1,-1,9,7,5,9,2,7,9,0,2,2,11,7,-1,-1,-1,-1,7,5,2,7,2,11,5,9,2,3,2,8,9,8,2,-1,2,5,10,2,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,8,2,0,8,5,2,8,7,5,10,2,5,-1,-1,-1,-1,9,0,1,5,10,3,5,3,7,3,10,2,-1,-1,-1,-1,9,8,2,9,2,1,8,7,2,10,2,5,7,5,2,-1,1,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,7,0,7,1,1,7,5,-1,-1,-1,-1,-1,-1,-1,9,0,3,9,3,5,5,3,7,-1,-1,-1,-1,-1,-1,-1,9,8,7,5,9,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,8,4,5,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,5,0,4,5,11,0,5,10,11,11,3,0,-1,-1,-1,-1,0,1,9,8,4,10,8,10,11,10,4,5,-1,-1,-1,-1,10,11,4,10,4,5,11,3,4,9,4,1,3,1,4,-1,2,5,1,2,8,5,2,11,8,4,5,8,-1,-1,-1,-1,0,4,11,0,11,3,4,5,11,2,11,1,5,1,11,-1,0,2,5,0,5,9,2,11,5,4,5,8,11,8,5,-1,9,4,5,2,11,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,5,10,3,5,2,3,4,5,3,8,4,-1,-1,-1,-1,5,10,2,5,2,4,4,2,0,-1,-1,-1,-1,-1,-1,-1,3,10,2,3,5,10,3,8,5,4,5,8,0,1,9,-1,5,10,2,5,2,4,1,9,2,9,4,2,-1,-1,-1,-1,8,4,5,8,5,3,3,5,1,-1,-1,-1,-1,-1,-1,-1,0,4,5,1,0,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,4,5,8,5,3,9,0,5,0,3,5,-1,-1,-1,-1,9,4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,11,7,4,9,11,9,10,11,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,7,9,11,7,9,10,11,-1,-1,-1,-1,1,10,11,1,11,4,1,4,0,7,4,11,-1,-1,-1,-1,3,1,4,3,4,8,1,10,4,7,4,11,10,11,4,-1,4,11,7,9,11,4,9,2,11,9,1,2,-1,-1,-1,-1,9,7,4,9,11,7,9,1,11,2,11,1,0,8,3,-1,11,7,4,11,4,2,2,4,0,-1,-1,-1,-1,-1,-1,-1,11,7,4,11,4,2,8,3,4,3,2,4,-1,-1,-1,-1,2,9,10,2,7,9,2,3,7,7,4,9,-1,-1,-1,-1,9,10,7,9,7,4,10,2,7,8,7,0,2,0,7,-1,3,7,10,3,10,2,7,4,10,1,10,0,4,0,10,-1,1,10,2,8,7,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,7,1,3,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,0,8,1,8,7,1,-1,-1,-1,-1,4,0,3,7,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,11,9,10,-1,-1,-1,-1,-1,-1,-1,0,1,10,0,10,8,8,10,11,-1,-1,-1,-1,-1,-1,-1,3,1,10,11,3,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,11,1,11,9,9,11,8,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,1,2,9,2,11,9,-1,-1,-1,-1,0,2,11,8,0,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,10,8,9,-1,-1,-1,-1,-1,-1,-1,9,10,2,0,9,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,0,1,8,1,10,8,-1,-1,-1,-1,1,10,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,8,9,1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,9,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,3,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]);function Qt(m,t,e){return .5*D.vec.norm(D.vec.cross(D.vec.create(m,t),D.vec.create(m,e)))}function Vt(m,t,e){const n=D.vec.create(e,t),a=D.vec.create(m,t);return D.vec.normalize(D.vec.cross(n,a))}function ye(m){let t=0,e=m.halfedge;const n=e.node.pos;e=e.next;do t+=Qt(n,e.node.pos,e.next.node.pos),e=e.next;while(e!==m.halfedge);return t}function Fe(m){let t=[0,0,0],e=m.halfedge;const n=e.node.pos;e=e.next;do{const a=Vt(n,e.node.pos,e.next.node.pos);Number.isNaN(a[0])||(t=D.vec.add(t,a)),e=e.next}while(e!==m.halfedge);return D.vec.normalize(t)}class Bt{constructor(){this.pos_=[0,0,0],this.id_=-1,this.he_=void 0}setPos(t,e,n){Array.isArray(t)?(this.pos_[0]=t[0],this.pos_[1]=t[1],this.pos_[2]=t[2]):(this.pos_[0]=t,this.pos_[1]=e,this.pos_[2]=n!==void 0?n:0)}setId(t){this.id_=t}get posVec3(){return this.pos_}get pos(){return this.pos_}get id(){return this.id_}get halfedge(){return this.he_}get isOnBorder(){let t=this.he_;if(t===void 0)return!0;do{if(t.isBorder)return!0;t=t.nextAroundNode}while(t!==this.he_);return!1}get degree(){let t=this.he_;if(t===void 0)return 0;let e=0;do e++,t=t.nextAroundNode;while(t!==this.he_);return e}setHalfedge(t){this.he_=t}}class we{constructor(){this.halfedge_=void 0,this.id_=-1}get halfedge(){return this.halfedge_}get degree(){let t=0,e=this.halfedge_;do t++,e=e.next;while(e!==this.halfedge_);return t}get nbEdges(){return this.degree}get nbNodes(){return this.degree}get isOnBorder(){let t=this.halfedge_;do{if(t.opposite.isBorder)return!0;t=t.next}while(t!==this.halfedge_);return!1}get barycenter(){let t=[0,0,0],e=this.halfedge_,n=0;do{const a=e.node.pos;t=t.map(((d,p)=>d+a[p])),e=e.next,++n}while(e!==this.halfedge_);return t=t.map((a=>a/n)),t}get isTriangle(){return this.halfedge_.next.next.next===this.halfedge_}get id(){return this.id_}get opposite(){return this.halfedge_.opposite.facet}setId(t){this.id_=t}setHalfedge(t){this.halfedge_=t}get nodes(){const t=[];let e=this.halfedge_;do t.push(e.node),e=e.next;while(e!==this.halfedge_);return t}get nodeIds(){const t=[];let e=this.halfedge_;do t.push(e.node.id),e=e.next;while(e!==this.halfedge_);return t}get area(){return ye(this)}get normal(){return Fe(this)}}class Te{constructor(){this.node_=void 0,this.opposite_=void 0,this.next_=void 0,this.prev_=void 0,this.facet_=void 0}get opposite(){return this.opposite_}get next(){return this.next_}get prev(){return this.prev_}get facet(){return this.facet_}get node(){return this.node_}get length(){const t=this.node.pos,e=this.prev.node.pos,n=[0,0,0];for(let a=0;a<3;++a)n[a]=t[a]-e[a];return Math.sqrt(n[0]**2+n[1]**2+n[2]**2)}get nextAroundNode(){return this.opposite.prev}get prevAroundNode(){return this.next.opposite}get isBorder(){return this.facet_===void 0}get isBorderEdge(){return this.isBorder||this.opposite.isBorder}setOpposite(t){this.opposite_=t}setNext(t){this.next_=t}setPrev(t){this.prev_=t}setFacet(t){this.facet_=t}setNode(t){this.node_=t}}class oe{constructor(){this.items=[]}push(t){this.items.push(t)}pop(){if(this.items.length!==0)return this.items.pop()}shift(){if(this.items.length!==0)return this.items.shift()}clear(){this.items=[]}get first(){return this.items.length===0?void 0:this.items[0]}get top(){return this.items.length===0?void 0:this.items[this.items.length-1]}get last(){return this.top}get isEmpty(){return this.items.length===0}get count(){return this.items.length}toString(){let t="";for(let e=0;e<this.items.length;e++)t+=this.items[e]+" ";return t}forEach(t){this.items.forEach(t,this)}map(t){return this.items.map(t,this)}}class Qe{notifiedRemove(t){}}class ae{constructor(){this.list_=[]}registerObserver(t){this.list_.push(t)}unregisterObserver(t){const e=this.list_.indexOf(t);e>-1&&this.list_.splice(e,1)}notifyRemove(t){this.list_.forEach((e=>e.notifiedRemove(t)))}}class xe{constructor(){this.node_observable_=new ae,this.facet_observable_=new ae,this.halfedge_observable_=new ae,this.surface_=void 0,this.facet_node_=new Array,this.nodes_=new Array,this.current_facet_=void 0,this.current_node_=void 0,this.current_halfedge_=void 0,this.first_node_in_facet_=void 0,this.first_halfedge_in_facet_=void 0,this.star_=new Map}beginSurface(t){this.surface_=t}endSurface(){this.terminateSurface(),this.nodes_=[]}reset(){}addNode(t){return this.addNodeInternal(t[0],t[1],t[2])}beginFacet(){this.facet_node_=[]}endFacet(){const t=this.facet_node_.length;if(t<3)throw new Error("SurfaceBuilder: Facet with less than 3 vertices");for(let e=0;e<t;e++){const n=(e+1)%t;this.findHalfedgeBetween(this.facet_node_[e],this.facet_node_[n])!==void 0&&(this.facet_node_[e]=this.copyNode(this.facet_node_[e]),this.facet_node_[n]=this.copyNode(this.facet_node_[n]))}this.beginFacetInternal();for(let e=0;e<t;e++)this.addNodeToFacetInternal(this.facet_node_[e]);return this.endFacetInternal(),this.currentFacet()}addNodeToFacet(t){t<0||t>=this.nodes_.length||this.facet_node_.push(this.nodes_[t])}surface(){return this.surface_}insertInStar(t){this.star_.set(t,[])}getOrCreateFromStar(t){return this.star_.has(t)===!1?(this.star_.set(t,[]),this.star_.get(t)):this.star_.get(t)}deleteFromStarIfEmpty(t){const e=this.star_.get(t);e!==void 0&&e.length===0&&this.star_.delete(t)}currentFacet(){return this.current_facet_}notifyRemoveNode(t){this.node_observable_.notifyRemove(t)}registerFacetObserser(t){this.facet_observable_.registerObserver(t)}unregisterFacetObserser(t){this.facet_observable_.unregisterObserver(t)}notifyRemoveFacet(t){this.facet_observable_.notifyRemove(t)}notifyRemoveHalfedge(t){this.halfedge_observable_.notifyRemove(t)}reindexNodes(){let t=0;this.nodes_.forEach((e=>e.setId(t++)))}reindexFacets(){let t=0;this.surface_.facets.forEach((e=>e.setId(t++)))}setSurface(t){this.surface_=t}addNodeInternal(t,e,n){const a=this.newNode();return Array.isArray(t)?a.setPos(t[0],t[1],t[2]):a.setPos(t,e,n!==void 0?n:0),this.nodes_.push(a),this.insertInStar(a),a}beginFacetInternal(){this.current_facet_=this.newFacet(),this.first_node_in_facet_=void 0,this.current_node_=void 0,this.first_halfedge_in_facet_=void 0,this.current_halfedge_=void 0}endFacetInternal(){const t=this.newHalfedgeBetween(this.current_node_,this.first_node_in_facet_);this.link(this.current_halfedge_,t,1),this.link(t,this.first_halfedge_in_facet_,1)}addNodeToFacetInternal(t){if(this.first_node_in_facet_===void 0)this.first_node_in_facet_=t;else{const e=this.newHalfedgeBetween(this.current_node_,t);this.first_halfedge_in_facet_===void 0?(this.first_halfedge_in_facet_=e,this.makeFacetKey(this.first_halfedge_in_facet_)):this.link(this.current_halfedge_,e,1),this.current_halfedge_=e}this.current_node_=t}copyNode(t){const e=this.newNode();return e.setPos(t.pos[0],t.pos[1],t.pos[2]),e}link(t,e,n){switch(n){case 1:t.setNext(e),e.setPrev(t);break;case 2:t.setOpposite(e),e.setOpposite(t)}}setNodeOnOrbit(t,e){let n=t;do n.setNode(e),n=n.nextAroundNode;while(n!==t)}setFacetOnOrbit(t,e){let n=t;do n.setFacet(e),n=n.next;while(n!==t)}makeNodeKey(t,e){e===void 0?t.node.setHalfedge(t):(e.setHalfedge(t),t.setNode(e))}makeFacetKey(t,e){e===void 0?t.facet.setHalfedge(t):(e.setHalfedge(t),t.setFacet(e))}newEdge(){return this.surface_.newEdge()}newNode(t){return this.surface_.newNode(t)}newHalfedge(t){return this.surface_.newHalfedge(t)}newFacet(t){return this.surface_.newFacet(t)}deleteEdge(t){this.notifyRemoveHalfedge(t),this.notifyRemoveHalfedge(t.opposite),this.surface_.deleteEdge(t)}deleteNode(t){this.notifyRemoveNode(t),this.surface_.deleteNode(t)}deleteHalfedge(t){this.notifyRemoveHalfedge(t),this.surface_.deleteHalfedge(t)}deleteFacet(t){t!==void 0&&(this.notifyRemoveFacet(t),this.surface_.deleteFacet(t))}setNodeHalfedge(t,e){t.setHalfedge(e)}setHalfedgeOpposite(t,e){t.setOpposite(e)}setHalfedgeNext(t,e){t.setNext(e)}setHalfedgePrev(t,e){t.setPrev(e)}setHalfedgeFacet(t,e){t.setFacet(e)}setHalfedgeNode(t,e){t.setNode(e)}setFacetHalfedge(t,e){t.setHalfedge(e)}newHalfedgeBetween(t,e){console.assert(this.findHalfedgeBetween(t,e)===void 0);const n=this.newHalfedge();this.setHalfedgeFacet(n,this.current_facet_),this.setHalfedgeNode(n,e);const a=this.findHalfedgeBetween(e,t);return a!==void 0&&this.link(n,a,2),this.getOrCreateFromStar(t).push(n),this.setNodeHalfedge(e,n),n}findHalfedgeBetween(t,e){let n;return this.getOrCreateFromStar(t).forEach((a=>{a.node==e&&(n=a)})),n}nodeIsManifold(t){return t.halfedge===void 0?(console.warn(`SurfaceBuilder: Warning, isolated vertex (${t.pos})`),!0):this.getOrCreateFromStar(t).length===t.degree}splitNonManifoldNode(t){if(this.nodeIsManifold(t))return!1;const e=new Set;for(this.getOrCreateFromStar(t).forEach((n=>e.add(n))),this.disconnectNode(t.halfedge.opposite,t,e),console.assert(e.size!==0);e.size!==0;){const n=this.copyNode(t),a=e[0];this.disconnectNode(a,n,e)}return!0}disconnectNode(t,e,n){let a=t;for(this.insertInStar(e),console.assert(n.has(a));!a.isBorder&&(a=a.prev.opposite,a!==t););this.setNodeHalfedge(e,a.opposite);let d=a;for(this.setHalfedgeNode(d.opposite,e),this.getOrCreateFromStar(e).push(d),n.delete(d);!d.opposite.isBorder&&(d=d.opposite.next,d!==a);)this.setHalfedgeNode(d.opposite,e),n.delete(d),this.getOrCreateFromStar(e).push(d);a.isBorder&&this.link(d.opposite,a,1)}terminateSurface(){this.updateBorder(this.star_),this.nodes_.forEach((t=>{this.splitNonManifoldNode(t)})),this.nodes_.forEach((t=>{this.deleteFromStarIfEmpty(t)})),this.reindexNodes(),this.reindexFacets()}updateBorder(t){const e=[];this.surface_.halfedges.forEach((n=>{n.opposite===void 0&&e.push(n)})),e.length!==0&&e.forEach((n=>{const a=this.newHalfedge();this.link(a,n,2),this.setHalfedgeNode(a,n.prev.node),t.get(n.node).push(a)})),this.surface_.halfedges.forEach((n=>{if(n.facet===void 0){let a=n.opposite;for(;a.facet!==void 0;)a=a.prev.opposite;this.setHalfedgeNext(n,a);let d=n.opposite;for(;d.facet!==void 0;)d=d.next.opposite;this.setHalfedgePrev(n,d)}}))}}class Pt{constructor(){this.list_n_=[],this.list_e_=[],this.list_f_=[],this.bbox_=void 0}beginDescription(){this.list_n_=[],this.list_e_=[],this.list_f_=[]}endDescription(){}static create(t,e){let n,a;n=R.Serie.isSerie(t)?t:R.Serie.create({array:t,itemSize:3}),a=R.Serie.isSerie(e)?e:R.Serie.create({array:e,itemSize:3});const d=new Pt;return d.build(n,a),d}get nodesAsSerie(){const t=new Array(3*this.list_n_.length).fill(0);for(let e=0;e<this.list_n_.length;++e){const n=this.list_n_[e],a=3*e;t[a]=n.pos[0],t[a+1]=n.pos[1],t[a+2]=n.pos[2]}return R.Serie.create({array:t,itemSize:3})}get trianglesAsSerie(){const t=new Array(3*this.list_f_.length).fill(0);for(let e=0;e<this.list_f_.length;++e){const n=this.list_f_[e].nodeIds,a=3*e;t[a]=n[0],t[a+1]=n[1],t[a+2]=n[2]}return R.Serie.create({array:t,itemSize:3})}build(t,e){const n=e.itemSize,a=new xe;a.beginSurface(this);const d=new U;t.forEach((p=>{a.addNode(p),d.grow(p)})),this.bbox_=d,e.forEach((p=>{a.beginFacet();for(let g=0;g<n;++g)a.addNodeToFacet(p[g]);a.endFacet()})),a.endSurface()}get bbox(){return this.bbox_}get nbNodes(){return this.list_n_.length}get nodes(){return this.list_n_}node(t){return this.list_n_[t]}forEachNode(t){const e=this.list_n_;for(let n=0;n<e.length;++n)t(e[n],n)}get halfedges(){return this.list_e_}get nbHalfedges(){return this.list_e_.length}halfedge(t){return this.list_e_[t]}forEachHalfedge(t){const e=this.list_e_;for(let n=0;n<e.length;++n)t(e[n],n)}get facets(){return this.list_f_}get nbFacets(){return this.list_f_.length}facet(t){return this.list_f_[t]}forEachFace(t){const e=this.list_f_;for(let n=0;n<e.length;++n)t(e[n],n)}get borderEdges(){const t=[];return this.halfedges.forEach((e=>{e.facet===void 0&&t.push(e)})),t}get bordersAsSerie(){const t=[];return this.halfedges.forEach((e=>{if(e.facet===void 0){const n=e.node,a=e.opposite.node;t.push(n.pos[0],n.pos[1],n.pos[2]),t.push(a.pos[0],a.pos[1],a.pos[2])}})),R.Serie.create({array:t,itemSize:3})}get borderIdsAsSerie(){const t=[];return this.halfedges.forEach((e=>{if(e.facet===void 0){const n=e.node,a=e.opposite.node;t.push(n.id,a.id)}})),R.Serie.create({array:t,itemSize:1})}get borderNodes(){const t=[];return this.halfedges.forEach((e=>{e.facet===void 0&&t.push(e.node,e.opposite.node)})),t}deleteEdge(t){this.deleteHalfedge(t.opposite),this.deleteHalfedge(t)}deleteHalfedge(t){this.list_e_=this.list_e_.filter((e=>e===t))}deleteFacet(t){this.list_f_=this.list_f_.filter((e=>e===t))}newHalfedge(t){const e=new Te;return this.addNewHalfedge(e),e}newNode(t){const e=new Bt;return t!==void 0&&e.setPos(t.pos[0],t.pos[1],t.pos[2]),this.addNewNode(e),e}deleteNode(t){this.list_n_=this.list_n_.filter((e=>e===t))}addNewNode(t){this.list_n_.push(t)}newFacet(t){const e=new we;return this.addNewFacet(e),e}newEdge(){const t=this.newHalfedge(),e=this.newHalfedge();return t.setOpposite(e),e.setOpposite(t),t.setNext(e),e.setNext(t),t.setPrev(e),e.setPrev(t),t}getConnectedComponent(t,e){const n=new Map;this.nodes.forEach((d=>n.set(d,!1)));const a=new oe;for(a.push(t);!a.isEmpty;){const d=a.top;if(a.pop(),!n.get(d)){n.set(d,!0),e.push(d);let p=d.halfedge;do{const g=p.opposite.node;n.get(g)||a.push(g),p=p.nextAroundNode}while(p!==d.halfedge)}}}addNewHalfedge(t){this.list_e_.push(t)}addNewFacet(t){this.list_f_.push(t)}}function he(m,t){let e=m.halfedge,n=0;do t(e.opposite.node,n++),e=e.nextAroundNode;while(e!==m.halfedge)}function Ve(m,t){let e=m,n=0;do t(e.opposite.node,n++),e=e.nextAroundNode;while(e!==m)}function ke(m,t){let e=m.halfedge,n=0;do t(e.facet,n++),e=e.nextAroundNode;while(e!==m.halfedge)}class _e extends xe{constructor(t){super(),this.is_modified_=!1,this.setSurface(t)}beginModif(){this.is_modified_=!0}endModif(){this.is_modified_=!1,this.reindexNodes(),this.reindexFacets()}eraseFacet(t){console.assert(this.is_modified_),console.assert(t!==void 0);let e=t.halfedge;console.assert(!e.isBorder);const n=[];this.deleteFacet(e.facet);const a=e;do{this.setHalfedgeFacet(e,void 0);const d=e.next,p=e.opposite.isBorder,g=d.opposite.isBorder;if(p)g&&(d.opposite.next==e.opposite?this.deleteNode(e.node):(this.makeNodeKey(e.opposite.prev),this.link(e.opposite.prev,d.opposite.next,1))),n.push(e);else if(e.next.opposite.isBorder&&(this.link(e,e.next.opposite.next,1),this.makeNodeKey(e)),e.prev.opposite.isBorder){const _=e.prev.opposite.prev;this.link(_,e,1),this.makeNodeKey(_)}e=d}while(e!==a);n.forEach((d=>this.deleteEdge(d)))}eraseNode(t){console.assert(this.is_modified_),console.assert(t),console.assert(t.halfedge);const e=[];let n=t.halfedge;do n.facet&&e.push(n.facet),n=n.nextAroundNode;while(n!==t.halfedge);return e.forEach((a=>this.eraseFacet(a))),!0}collapse_node(t,e=!0){if(console.assert(this.is_modified_),t.halfedge.opposite.isBorder&&t.halfedge.next.opposite.isBorder)return;{let d,p=t.halfedge;do{if(p.isBorder){d=p;break}p=p.nextAroundNode}while(p!==t.halfedge);if(d!==void 0){if(d.prev==d.next)return;this.addFacetToBorder(d.prev,d.next)}}const n=t.halfedge.prev;let a=n;do{let d=a.next;d.node===t&&(d=d.opposite.next,this.deleteEdge(a.next),this.deleteFacet(a.facet),this.link(a,d,1),this.makeNodeKey(a)),a=d}while(a!==n);return this.setFacetOnOrbit(n,this.newFacet()),this.makeFacetKey(n),this.deleteNode(t),e&&this.triangulateFacet(n),n}addFacetToBorder(t,e){console.assert(this.is_modified_),console.assert(t.isBorder),console.assert(e.isBorder),console.assert(t!==e),console.assert(this.halfedgesOnSameFacet(t,e));const n=t.next,a=e.next,d=this.newEdge();return this.link(d,n,1),this.setHalfedgeNode(d,t.node),this.link(e,d,1),this.setHalfedgeNode(d.opposite,e.node),this.link(t,d.opposite,1),this.link(d.opposite,a,1),this.setFacetOnOrbit(d,this.newFacet()),this.makeFacetKey(d),d}halfedgesOnSameFacet(t,e){let n=t;do{if(n==e)return!0;n=n.next}while(n!==t);return!1}canSplitFacet(t,e){return t!==e&&!!this.halfedgesOnSameFacet(t,e)&&t.next!==e&&e.next!==t}splitFacet(t,e){if(console.assert(this.is_modified_),!this.canSplitFacet(t,e))return!1;const n=this.newEdge();return this.link(n.opposite,e.next,1),this.link(n,t.next,1),this.link(e,n,1),this.link(t,n.opposite,1),this.setHalfedgeNode(n,t.node),this.setHalfedgeNode(n.opposite,e.node),this.makeFacetKey(n.opposite,t.facet),this.setFacetOnOrbit(n,this.newFacet()),this.makeFacetKey(n),!0}triangulateFacet(t){console.assert(this.is_modified_);let e=t.next.next;for(;e.next!=t;)this.splitFacet(t,e),e=e.next.opposite.next}createCenterNode(t){console.assert(this.is_modified_);const e=t.halfedge,n=this.newNode(),a=t.barycenter;this.deleteFacet(t);let d=!0,p=e;do{const g=p.next,_=this.newEdge();this.link(p,_,1),this.link(_.opposite,g,1),this.setHalfedgeNode(_,n),this.setHalfedgeNode(_.opposite,p.node),d?(d=!1,this.makeNodeKey(_)):(this.link(_,p.prev,1),this.setFacetOnOrbit(p,this.newFacet()),this.makeFacetKey(p)),p=g}while(p!==e);return this.link(e.next,e.prev,1),this.setFacetOnOrbit(e,this.newFacet()),this.makeFacetKey(e),n.setPos(a),n}canSwitchEdge(t){return!(t.isBorder||t.opposite.isBorder||!t.facet||!t.opposite.facet||!t.facet.isTriangle||!t.opposite.facet.isTriangle)}switchEdge(t){if(console.assert(this.is_modified_),!this.canSwitchEdge(t))return!1;const e=t.next,n=t.next.next;let a=t.opposite;const d=a.next,p=a.next.next;return this.deleteFacet(t.facet),this.deleteFacet(a.facet),this.deleteEdge(t),t=this.newHalfedge(),a=this.newHalfedge(),this.link(t,a,2),this.setHalfedgeNode(t,e.node),this.setHalfedgeNode(a,d.node),this.link(t,n,1),this.link(n,d,1),this.link(d,t,1),this.makeNodeKey(t),this.makeNodeKey(n),this.makeNodeKey(d),this.setFacetOnOrbit(t,this.newFacet()),this.makeFacetKey(t),this.link(a,p,1),this.link(p,e,1),this.link(e,a,1),this.makeNodeKey(p),this.setFacetOnOrbit(a,this.newFacet()),this.makeFacetKey(a),!0}fillHole(t,e){if(console.assert(this.is_modified_),!t.isBorder)return;const n=this.newFacet();return this.setFacetOnOrbit(t,n),this.makeFacetKey(t),e&&this.triangulateFacet(t),t}makePolygon(t){let e,n;console.assert(this.is_modified_);for(let a=0;a<t;a++)e===void 0?(e=this.newEdge(),n=e,this.makeFacetKey(n,this.newFacet())):(this.link(n,this.newEdge(),1),this.link(n.next.opposite,n.opposite,1),this.setHalfedgeFacet(n.next,n.facet),this.setHalfedgeNode(n.next.opposite,n.node),n=n?n.next:void 0),this.makeNodeKey(n,this.newNode());return this.link(n,e,1),this.link(e.opposite,n.opposite,1),this.setHalfedgeNode(e.opposite,n.node),e}makeTriangle(t,e,n){if(console.assert(this.is_modified_),t===void 0)return this.makePolygon(3);if(console.assert(e!==void 0),console.assert(n!==void 0),Array.isArray(t)){const g=this.makeTriangle();return g.node.setPos(t),g.next.node.setPos(e),g.next.next.node.setPos(n),g}let a,d;const p=Array(3).fill(void 0);p[0]=t,p[1]=e,p[2]=n;for(let g=0;g<3;g++){if(a===void 0)a=this.newEdge(),d=a,this.makeFacetKey(d,this.newFacet());else{if(this.link(d,this.newEdge(),1),this.link(d.next.opposite,d.opposite,1),this.setHalfedgeFacet(d.next,d.facet),this.setHalfedgeNode(d.next.opposite,d.node),!d)throw new Error("cur is undefined");d=d.next}this.makeNodeKey(d,p[g])}return this.link(d,a,1),this.link(a.opposite,d.opposite,1),this.setHalfedgeNode(a.opposite,d.node),a}halfedgeBetween(t,e){let n=e.halfedge;do{if(n.opposite.node==t)return n;n=n.nextAroundNode}while(n!==e.halfedge)}swapNode(t,e){}createFacet(t,e,n){console.assert(this.is_modified_);const a=this.halfedgeBetween(t,e),d=this.halfedgeBetween(e,n),p=this.halfedgeBetween(n,t);a!==void 0&&a.node===e&&this.swapNode(t,e),d!==void 0&&d.node===n&&this.swapNode(e,n),p!==void 0&&p.node===t&&this.swapNode(n,t);const g=this.makeTriangle(t,e,n);return a&&this.glue(a.isBorder?a:a.opposite,g.next.isBorder?g.next:g.next.opposite),d&&this.glue(d.isBorder?d:d.opposite,g.next.next.isBorder?g.next.next:g.next.next.opposite),p&&this.glue(p.isBorder?p:p.opposite,g.isBorder?g:g.opposite),!0}canGlue(t,e){return!(!t.isBorder||!e.isBorder||t.opposite.facet==e.opposite.facet||this.halfedgeExistsBetweenNodes(t.node,e.opposite.node)||this.halfedgeExistsBetweenNodes(e.node,t.opposite.node)||!this.canMergeNodes(t,e.opposite)||!this.canMergeNodes(e,t.opposite))}barycenter(t,e){return[(t[0]+e[0])/2,(t[1]+e[1])/2,(t[2]+e[2])/2]}glue(t,e){if(console.assert(this.is_modified_),!this.canGlue(t,e))return!1;const n=this.barycenter(t.node.pos,e.opposite.node.pos),a=this.barycenter(e.node.pos,t.opposite.node.pos),d=t.node,p=e.node,g=t.opposite.node,_=e.opposite.node;return g!=p&&(this.setNodeOnOrbit(e,g),this.deleteNode(p)),_!=d&&(this.setNodeOnOrbit(t,_),this.deleteNode(d)),this.link(e.prev,t.next,1),this.link(t.prev,e.next,1),this.link(t.opposite,e.opposite,2),this.makeNodeKey(t.opposite),this.makeNodeKey(e.opposite),_.setPos(n),g.setPos(a),this.deleteHalfedge(t),this.deleteHalfedge(e),!0}canMergeNodes(t,e){return t.node===e.node||this.orbitsAreCompatible(t,e)&&this.orbitsAreCompatible(e,t)}halfedgeExistsBetweenNodes(t,e){let n=t.halfedge;do{if(n.opposite.node==e)return!0;n=n.nextAroundNode}while(n!==t.halfedge);return!1}orbitsAreCompatible(t,e){let n=t;do{let a=0;const d=n.opposite;let p=e;do{const g=p.opposite;if(d.node===g.node||d.node===t.opposite.node&&g.node===e.opposite.node||d.node===e.opposite.node&&g.node===t.opposite.node){if(!(d.opposite.isBorder&&g.isBorder||d.isBorder&&g.opposite.isBorder))return!1;a++}p=p.nextAroundNode}while(p!==e);if(a>1)return!1;n=n.nextAroundNode}while(n!==t);return!0}canUnglue(t){return!t.isBorderEdge&&(t.node.isOnBorder||t.opposite.node.isOnBorder)}unglue(t,e){if(console.assert(this.is_modified_),e&&!this.canUnglue(t)||t.isBorderEdge)return!1;const n=t.opposite,a=t.node,d=n.node,p=a.isOnBorder,g=d.isOnBorder;console.assert(!e||p||g);const _=this.newEdge(),x=_.opposite;if(this.link(t,_,2),this.link(n,x,2),g){let w=t.prev.opposite;for(;!w.isBorder;)w=w.prev.opposite;console.assert(w!=t);let v=n.next.opposite;for(;!v.isBorder;)v=v.next.opposite;console.assert(v!=n),console.assert(v.node==d),console.assert(v.next==w),this.link(_,w,1),this.link(v,x,1),this.setNodeOnOrbit(_,this.newNode(d)),this.makeNodeKey(_),this.makeNodeKey(n)}else this.setHalfedgeNode(_,d);if(p){let w=t.next.opposite;for(;!w.isBorder;)w=w.next.opposite;console.assert(w!=t);let v=n.prev.opposite;for(;!v.isBorder;)v=v.prev.opposite;console.assert(v!=n),console.assert(w.next==v),this.link(w,_,1),this.link(x,v,1),this.setNodeOnOrbit(x,this.newNode(a)),this.makeNodeKey(x),this.makeNodeKey(t)}else this.setHalfedgeNode(x,a);return!0}flipNormals(){console.assert(this.is_modified_),this.surface_.facets.forEach((t=>{this.flipNormal(t.halfedge)})),this.surface_.halfedges.forEach((t=>{t.isBorder&&t.node===t.opposite.node&&this.flipNormal(t)}))}flipNormal(t){if(console.assert(this.is_modified_),t===void 0)return;const e=t;let n=t;const a=t;t=t.next;let d=a.node;for(;t!==e;){const g=t.node;this.setHalfedgeNode(t,d),this.setNodeHalfedge(t.node,t),d=g;const _=t.next;this.setHalfedgeNext(t,n),this.setHalfedgePrev(t,_),n=t,t=_}this.setHalfedgeNode(a,d),this.setNodeHalfedge(a.node,a);const p=a.next;this.setHalfedgeNext(a,n),this.setHalfedgePrev(a,p)}zipEdge(t){let e,n;console.assert(this.is_modified_);let a=t.halfedge;do a.isBorder&&(e===void 0?e=a:n=a),a.opposite.isBorder&&(e===void 0?e=a.opposite:n=a.opposite),a=a.nextAroundNode;while(a!==t.halfedge);return e!==void 0&&n!==void 0&&this.glue(e,n),!0}}class Dt{constructor(t){this._valid=!0,this._name=t}get name(){return this._name}set name(t){this._name=t}get valid(){return this._valid}set valid(t){this._valid=t}}class Yt extends Dt{constructor(t,e,n="function-action"){super(n),this._do=void 0,this._undo=void 0,this._do=t,this._undo=e}do(){this._do()}undo(){this._undo()}}class ce extends Dt{constructor(t="macro-action"){super(t),this._actions=[]}register(t,e){t instanceof Dt?t.valid===!0&&this._actions.push(t):(console.assert(e!==void 0),this._actions.push(new Yt(t,e)))}do(){this._actions.forEach((t=>t.do()))}undo(){this._actions.reverse().forEach((t=>t.undo())),this._actions.reverse()}}class ue{constructor(t=10){this._undo=new oe,this._do=new oe,this._size=10,this._size=t}execute(t,e,n){let a;if(t instanceof Dt){if(t.valid===!1)return!1;a=t}else console.assert(e!==void 0),a=new Yt(t,e,n);return this._do.push(a),a.do(),this._do.count>this._size&&this._do.shift(),this._undo.count!==0&&this._undo.clear(),!0}undo(t=1){for(let e=0;e<t;++e)this.__undo()}redo(t=1){for(let e=0;e<t;++e)this.__redo()}clear(){this._do.clear(),this._undo.clear()}get maxSize(){return this._size}set maxSize(t){this._size=t}get undoActionNames(){return this._do.map((t=>t.name)).reverse()}get redoActionNames(){return this._undo.map((t=>t.name)).reverse()}__undo(){if(this._do.count===0)return;const t=this._do.last;return this._do.pop(),t.undo(),this._undo.push(t),this._undo.count>this._size&&this._undo.shift(),t}__redo(){if(this._undo.count===0)return;const t=this._undo.last;return this._undo.pop(),t.do(),this._do.push(t),this._do.count>this._size&&this._do.shift(),t}}class Oe extends Dt{constructor(t,e){super("Move node"),this.n=t,this.translation=e,this.node=void 0,t===void 0&&(this.valid=!1),this.node=t}do(){const t=this.node.pos.map(((e,n)=>e+this.translation[n]));this.node.setPos(t)}undo(){const t=this.node.pos.map(((e,n)=>e-this.translation[n]));this.node.setPos(t)}}class Be extends Qe{constructor(){super(...arguments),this.facets=[]}notifiedRemove(t){this.facets.push(t)}clear(){this.facets=[]}}class Pe extends Dt{constructor(t,e){super("Fill hole"),this.surface=t,this.h=e,this.edt=void 0,this.observer=new Be,this.edt=new _e(t),e!==void 0&&e.isBorder!==!1||(this.valid=!1)}do(){this.observer.clear(),this.edt.registerFacetObserser(this.observer),this.edt.beginModif(),this.edt.fillHole(this.h,!0),this.edt.endModif(),this.edt.unregisterFacetObserser(this.observer)}undo(){this.edt.beginModif(),this.observer.facets.forEach((t=>this.edt.deleteFacet(t))),this.edt.endModif()}}class Ze{constructor(t,e){this.surface=void 0,this.surface=Pt.create(t,e)}interpolate({serie:t,atTriangles:e=!1,localCsys:n=!0}){if(t.itemSize!==3)throw new Error("For the moment, only series with itemSize = 3 is allowed");if(t.count!==this.surface.nbFacets)throw new Error(`serie must be either defined at triangles (count=${this.surface.nbFacets}). Got count=${t.itemSize}`);if(e==1){const a=t.image(t.count,3),d=a.array;let p=0;return this.surface.forEachFace(((g,_)=>{let x=t.itemAt(_);n===!1&&(x=new ct(g.normal).toGlobal(x)),d[p++]=x[0],d[p++]=x[1],d[p++]=x[2]})),a}{const a=t.image(this.surface.nbNodes,3),d=a.array,p=new Array(this.surface.nbNodes).fill([0,0,0]),g=new Array(this.surface.nbNodes).fill(0);this.surface.forEachFace(((x,w)=>{const v=x.nodeIds;let b=t.itemAt(w);n===!1&&(b=new ct(x.normal).toGlobal(b));for(let N=0;N<3;++N){for(let E=0;E<3;++E)p[v[N]][E]+=b[E];g[v[N]]++}for(let N=0;N<this.surface.nbNodes;++N){const E=g[N];for(let I=0;I<3;++I)p[N][I]/=E}}));let _=0;return p.forEach((x=>{d[_++]=x[0],d[_++]=x[1],d[_++]=x[2]})),a}}}function He(m){if(m.itemSize!==3)throw new Error("Only triangles are allowed");return m.map((t=>[t[0],t[2],t[1]]))}function ti(m,t){return Pt.create(m,t).bordersAsSerie}function $e(m,t,e){let n=!1;if(e.itemSize!==2&&e.itemSize!==3)throw new Error("bad Serie for polyline. Should be coords in 2D or 3D");const a=e.itemSize,d=e.count,p=e.array;for(let g=0,_=d-1;g<d;_=g++){const x=p[a*g],w=p[a*g+1],v=p[a*_+1];w>t!=v>t&&m<(p[a*_]-x)*(t-w)/(v-w)+x&&(n=!n)}return n}function Re(m,t=100){const e=(0,D.minMax)(m),n=new U([e[0],e[1],m.itemSize===3?e[2]:0],[e[3],e[4],m.itemSize===3?e[5]:0]);let a=0;for(;;){const d=n.randPoint();if($e(d[0],d[1],m))return[d[0],d[1]];if(a>t)return;a++}}class Le{get backgroundGrid(){return this.bg}constructor({positions:t,indices:e,attribute:n,nx:a,ny:d,flatten:p=!0,scaling:g=1}){this.positions=void 0,this.indices=void 0,this.attribute=void 0,this.bg=void 0,this.eps=1e-7,this.indices=e,this.attribute=n,this.positions=t.map((_=>[_[0]*g,_[1]*g,p?0:_[2]])),this.bg=z({positions:this.positions,indices:this.indices,dims:[a,d]}),this.eps=1e-4*Math.max(this.bg.bbox.width,this.bg.bbox.height)}interpolate(t){const e=(a,d,p,g)=>{const _=w=>w>=-this.eps&&w<=1+this.eps,x=(0,D.barycentric2)(a,d,p,g);return _(x[0])&&_(x[1])&&_(x[2])},n=this.bg.candidates(t);if(n&&n.length)for(let a=0;a<n.length;++a){const d=n[a].obj,p=this.indices.itemAt(d),g=this.positions.itemAt(p[0]),_=this.positions.itemAt(p[1]),x=this.positions.itemAt(p[2]);if(e(t,g,_,x)){const w=this.attribute.itemAt(p[0]),v=this.attribute.itemAt(p[1]),b=this.attribute.itemAt(p[2]);return(0,D.triangleLerp2D)([t[0],t[1]],[g[0],g[1]],[_[0],_[1]],[x[0],x[1]],w,v,b)}}}}class ei{constructor(t,e,n=0){this.positions=t,this.indices=e,this.surface_=void 0,this.map=new Map,this.constrainedNodes=[],this.maxIter_=618,this.eps_=382e-8,this.epsilon_=.5,this.dataSize=1,this.surface_=Pt.create(t,e),Array.isArray(n)?(this.surface_.forEachNode((a=>this.map.set(a,[...n]))),this.dataSize=n.length):(this.surface_.forEachNode((a=>this.map.set(a,new Array(1).fill(n)))),this.dataSize=1)}get surface(){return this.surface_}set maxIter(t){this.maxIter_=t}set eps(t){this.eps_=t}set epsilon(t){this.epsilon_=t}constrainsBorders(t){this.surface_.borderNodes.forEach((e=>this.addConstraint(e,t)))}addConstraint(t,e){if(Array.isArray(e)){if(e.length!==this.dataSize)throw new Error(`array length problem. Should be ${this.dataSize}`)}else if(this.dataSize!==1)throw new Error(`value problem. Should be an array of size ${this.dataSize}`);if(Array.isArray(t)){const n=this.findNode(t);n&&this.constrainedNodes.includes(n)===!1&&this.pushNode(n,e)}else this.constrainedNodes.includes(t)===!1&&this.pushNode(t,e)}solve({name:t="property",record:e=!1,step:n=0}){let a=1,d=0,p=1;const g=new Map(this.map),_=R.DataFrame.create({series:{positions:this.positions,indices:this.indices}});for(;a>this.eps_;){if(a=0,this.surface_.forEachNode((v=>{if(this.constrainedNodes.includes(v)===!1){const b=new Array(this.dataSize).fill(0);let N=0;he(v,(I=>{N++,this.add(this.map.get(I),b)})),this.scale(b,1/N);const E=this.map.get(v);this.scale(b,this.epsilon_),this.add(this.scale(E,1-this.epsilon_),b),this.map.set(v,b),a+=this.norm2(b,this.scale(E,1/(1-this.epsilon_)))}})),a=Math.sqrt(a),e&&n>0&&d%n==0){let v=0;const b=new Array(this.map.size*this.dataSize).fill(0);this.map.forEach((N=>N.forEach((E=>b[v++]=E)))),_.series[`${t}${p++}`]=R.Serie.create({array:b,itemSize:this.dataSize})}if(d++,d>this.maxIter_)break}console.log("HarmonicDiffusion nb iter:",d),console.log("HarmonicDiffusion conv   :",a);let x=0;const w=new Array(this.map.size*this.dataSize).fill(0);if(this.map.forEach((v=>v.forEach((b=>w[x++]=b)))),_.series[t]=R.Serie.create({array:w,itemSize:this.dataSize}),e&&n===0){let v=0;const b=new Array(this.map.size*this.dataSize).fill(0);g.forEach((N=>N.forEach((E=>b[v++]=E)))),_.series[`${t}_init`]=R.Serie.create({array:b,itemSize:this.dataSize})}return _}add(t,e){return t.forEach(((n,a)=>e[a]+=n)),e}norm2(t,e){return t.reduce(((n,a,d)=>n+(a-e[d])**2),0)}scale(t,e){for(let n=0;n<t.length;++n)t[n]*=e;return t}pushNode(t,e){Array.isArray(e)?this.map.set(t,e):this.map.set(t,[e]),this.constrainedNodes.push(t)}findNode(t){let e,n=Number.POSITIVE_INFINITY;return this.surface_.forEachNode((a=>{const d=(a.pos[0]-t[0])**2+(a.pos[1]-t[1])**2+(a.pos[2]-t[2])**2;d<n&&(n=d,e=a)})),e}}class ii{constructor({nx:t,ny:e,min:n={x:0,y:0},max:a={x:1,y:1}}){this.nx_=0,this.ny_=0,this.values_=new Map,this.min_={x:0,y:0},this.max_={x:1,y:1},this.nx_=t,this.ny_=e,this.min_=n,this.max_=a}nbPoints(){return this.nx_*this.ny_}nx(){return this.nx_}ny(){return this.ny_}min(){return this.min_}max(){return this.max_}getData(t,e,n){const a=e*this.nx_+n;return this.values_.get(t).itemAt(a)}addAttribute(t,e){if(e.count!==this.nbPoints())throw new Error(`count mistmatch. Serie count (${e.count}) <> Square nb points (${this.nbPoints()})`);this.values_.has(t)&&console.warn(`Serie named ${t} already exists in Square`),this.values_.set(t,e)}createAttribute(t,e=1){this.values_.has(t)&&console.warn(`Serie named ${t} already exists in Square`);const n=R.Serie.create({array:new Array(this.nx_*this.ny_*e).fill(0),itemSize:e});return this.values_.set(t,n),n}getAttribute(t){return this.values_.get(t)}}class ri{constructor(){this.ni_=0,this.nj_=0,this.ni_node_=0,this.nj_node_=0,this.bad_data_=!1,this.square_=void 0,this.serie=void 0}setup(t,e){if(this.square_=t,this.serie=t.getAttribute(e),this.serie===void 0)throw new Error("Serie is undefined");if(this.serie.itemSize!==1)throw new Error("itemSize of Serie is not 1");this.ni_=this.square_.nx()-1,this.nj_=this.square_.ny()-1,(this.ni_<1||this.nj_<1)&&(this.bad_data_=!0),this.ni_node_=this.ni_+1,this.nj_node_=this.nj_+1}getIsolines(t){const e=[];if(this.bad_data_||this.serie===void 0)return e;const n=(x,w)=>this.serie.itemAt(x*this.square_.nx()+w),a=[0,0,0,0];let d=4*t;const p=new Map,g=new Map;for(let x=0;x<this.nj_;++x){let w=x+1;for(let v=0;v<this.ni_;++v){let b=v+1;a[0]=n(v,x),a[1]=n(b,x),a[2]=n(b,w),a[3]=n(v,w);let N=si[a[0]>=t?1:0][a[1]>=t?1:0][a[2]>=t?1:0][a[3]>=t?1:0];if(N!=0&&N!=15){if(N==5||N==10){let E=a[0]+a[1]+a[2]+a[3]<d;N==5&&E?N=10:N!=10||E||(N=5)}for(let E=0;E<3;E+=2){let I=de[N][E];if(I==-1)break;let T=de[N][E+1],B=v+Nt[I][0],F=x+Nt[I][1],j=B+F*this.ni_node_,H=(I+1)%4,nt=v+Nt[H][0],it=x+Nt[H][1],Y=nt+it*this.ni_node_,tt=Math.min(j,Y)+Math.max(F,it)*this.ni_;if(g.get(tt)===void 0){let W=(t-a[I])/(a[H]-a[I]);const $=[];$.push(B+(nt-B)*W),$.push(F+(it-F)*W),g[tt]=$}let dt=v+Nt[T][0],V=x+Nt[T][1],K=dt+V*this.ni_node_,X=(T+1)%4,Q=v+Nt[X][0],ot=x+Nt[X][1],lt=Q+ot*this.ni_node_,et=Math.min(K,lt)+Math.max(V,ot)*this.ni_;if(g.get(et)===void 0){let W=(t-a[T])/(a[X]-a[T]);const $=[];$.push(dt+(Q-dt)*W),$.push(V+(ot-V)*W),g[et]=$}p[tt].push(et),p[et].push(tt)}}}}let _=p.size;if(_>1)do{let x=-1;const w=[];for(let[T,B]of p)if(B.length===1){x=T;break}x==-1&&(p.entries().next().value,x=p[0]);const v=[],b=g[x];v.push(b[0]),v.push(b[1]),w.push(x);let N=p[x][0],E=x,I=!0;do{if(N==E){v.push(b[0]),v.push(b[1]);break}const T=g[N];v.push(T[0]),v.push(T[1]),w.push(N);const B=p[N];I=!1;for(let F=0;F<B.size();++F)if(B[F]!=x){x=N,N=B[F],I=!0;break}}while(I);e.push(R.Serie.create({array:v,itemSize:2}));for(let T=0;T<w.length;++T)p.delete(w[T]),g.delete(w[T]),--_}while(_>0);return e}}const de=[[-1,-1,-1,-1],[3,0,-1,-1],[0,1,-1,-1],[1,3,-1,-1],[1,2,-1,-1],[0,1,2,3],[0,2,-1,-1],[2,3,-1,-1],[2,3,-1,-1],[0,2,-1,-1],[1,2,3,0],[1,2,-1,-1],[1,3,-1,-1],[0,1,-1,-1],[3,0,-1,-1],[-1,-1,-1,-1]],si=[[[[0,8],[4,12]],[[2,10],[6,14]]],[[[1,9],[5,13]],[[3,11],[7,15]]]],Nt=[[0,0],[1,0],[1,1],[0,1]];function jt(m){return m*Math.PI/180}function De(m){const t=new Kt(m);return{positions:t.positions,indices:t.indices}}class Kt{constructor(t){if(t===void 0)throw new Error("data for trace is undefned");if(t.points.itemSize!==2&&t.points.itemSize!==3)throw new Error("points must be a Serie with itemSize equals to 2 or 3");this.info=t,this.info.depth===void 0&&(this.info.depth=.1),this.info.dip===void 0&&(this.info.dip=30),this.info.dipDirection===void 0&&(this.info.dipDirection=90),this.info.rows===void 0&&(this.info.rows=5),this.info.id===void 0&&(this.info.id="no-name"),this.perform()}pt(t){return this.info.points.itemAt(t)}perform(){const t=this.info.rows,e=this.info.points.count,n=jt(this.info.dip),a=jt(this.info.dipDirection),d=this.info.depth/(t-1),p=[d*Math.sin(a)*Math.cos(n),d*Math.cos(a)*Math.cos(n),d*Math.sin(n)],g=[],_=[];for(let x=0;x<t;++x)for(let w=0;w<e;++w){const v=this.pt(w);v.length===3?g.push(v[0]+x*p[0],v[1]+x*p[1],v[2]-x*p[2]):g.push(v[0]+x*p[0],v[1]+x*p[1],-x*p[2])}for(let x=0;x<t-1;++x){const w=x*e;for(let v=0;v<e-1;++v){const b=w+v;_.push(b,1+b,e+b,1+b,e+1+b,e+b)}}this.positions=R.Serie.create({array:g,itemSize:3}),this.indices=R.Serie.create({array:_,itemSize:3})}}function Zt(m,t){const e=new ve;return e.setMnt(m),e.setTraces(t),e.run()}class ve{constructor(){this.mnt=void 0,this.active=!0,this.mnt=void 0,this.traces=void 0}setMnt(t){this.mnt=t}setTraces(t){this.traces=t}run(){if(!this.mnt||this.traces.length===0)return;const t=new U;this.mnt.positions.forEach((n=>{t.grow(n)}));const e=[];return this.traces.forEach((n=>{const a=[];n.points.forEach((d=>{if(this.active){let p=!1;for(let g=0;g<this.mnt.indices.length;g+=3){const _=this.mnt.indices.array[g],x=this.mnt.indices.array[g+1],w=this.mnt.indices.array[g+2],v=this.mnt.positions.itemAt(_),b=this.mnt.positions.itemAt(x),N=this.mnt.positions.itemAt(w),E=(v[2]+b[2]+N[2])/3;if(this.pointInTriangle(d,v,b,N)){a.push(d[0],d[1],E),p=!0;break}}console.assert(p)}else a.push(d[0],d[1],0)})),e.push(R.Serie.create({array:a,itemSize:3}))})),e}pointInTriangle(t,e,n,a){function d(x,w,v){return(x[0]-v[0])*(w[1]-v[1])-(w[0]-v[0])*(x[1]-v[1])}const p=d(t,e,n),g=d(t,n,a),_=d(t,a,e);return!((p<0||g<0||_<0)&&(p>0||g>0||_>0))}}const Se=(m,t=1e-7)=>{const e=m.itemAt(0)[0];let n=0;if(m.forEach((d=>{Math.abs(d[0]-e)<t&&n++})),n<2)return void console.warn("Seems that the grid is not regular");const a=m.count/n;if(Number.isInteger(a)!==!1)return[n,a];console.warn("Seems that the grid is not regular")};class _t{constructor(t,e){this.x=t,this.y=e}equals(t){return this.x===t.x&&this.y===t.y}add(t){return new _t(this.x+t.x,this.y+t.y)}mulScalar(t){return new _t(this.x*t,this.y*t)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();this.x/=t,this.y/=t}distanceTo(t){const e=t.x-this.x,n=t.y-this.y;return Math.sqrt(e*e+n*n)}}class je{constructor(t,e=1){if(this.bounds=[0,0,0,0,0,0],this.width=0,this.height=0,this.length=0,this.center=[0,0],t.length!==6)throw new Error("bounds is an array of length 6 ([xmin,ymin,zmin, xmax,ymax,zmax])");this.bounds=t,this.width=(t[3]-t[0])*e,this.height=(t[4]-t[1])*e,this.length=Math.max(this.width,this.height),this.center=[(t[3]+t[0])/2,(t[4]+t[1])/2]}normalize(t){if(R.Serie.isSerie(t))return t.map((a=>this.normalize(a)));const e=(t[0]-this.center[0])/this.length,n=(t[1]-this.center[1])/this.length;return t.length===2?[e,n]:[e,n,t[2]]}denormalize(t){if(t instanceof R.Serie)return t.map((a=>this.denormalize(a)));const e=t[0]*this.length+this.center[0],n=t[1]*this.length+this.center[1];return t.length===2?[e,n]:[e,n,t[2]]}}class Ge{constructor(){this.children=void 0}occupy(t){this.children===void 0&&(this.children=[]),this.children.push(t)}isTaken(t,e,n){if(this.children===void 0)return!1;for(let a=0;a<this.children.length;++a){const d=this.children[a],p=d.x-t,g=d.y-e;if(n(Math.sqrt(p*p+g*g),d))return!0}return!1}}function Ht(m,t,e){const n=Math.max(m.width,m.height),a=Math.ceil(n/t),d=new Map;return{occupyCoordinates:function(_){(function(x,w){(function(I,T){if(m.left>I||m.left+n<I)throw new Error(`x (${I}) is out of bounds (${m.left}, ${m.left+n})`);if(m.top>T||m.top+n<T)throw new Error(`y (${T}) is out of bounds (${m.top}, ${m.top+n})`)})(x,w);const v=p(x);let b=d.get(v);b||(b=new Map,d.set(v,b));const N=g(w);let E=b.get(N);return E||(E=new Ge,b.set(N,E)),E})(_.x,_.y).occupy(_)},isTaken:function(_,x,w){if(!d)return!1;const v=p(_),b=g(x);for(let N=-1;N<2;++N){const E=v+N;if(E<0||E>=a)continue;const I=d.get(E);if(I)for(let T=-1;T<2;++T){const B=b+T;if(B<0||B>=a)continue;const F=I.get(B);if(F&&F.isTaken(_,x,w))return!0}}return!1},isOutside:function(_,x){return e!==void 0?!e(_,x):_<m.left||_>m.left+m.width||x<m.top||x>m.top+m.height}};function p(_){return Math.floor(a*(_-m.left)/n)}function g(_){return Math.floor(a*(_-m.top)/n)}}function Ye(m,t,e){const n=e(m);if(!n)return;const a=e(m.add(n.mulScalar(.5*t)));if(!a)return;const d=e(m.add(a.mulScalar(.5*t)));if(!d)return;const p=e(m.add(d.mulScalar(t)));return p?n.mulScalar(t/6).add(a.mulScalar(t/3)).add(d.mulScalar(t/3)).add(p.mulScalar(t/6)):void 0}var St,yt;function Ke(m,t,e){const n=[m];let a=m,d=St.FORWARD,p=null,g=-1;const _=Ht(e.boundingBox,.9*e.timeStep,e.isOutsideFct);return{start:m,next:function(){for(;;){if(p=null,e.maximumPointsPerLine&&n.length>e.maximumPointsPerLine&&(d=St.DONE),d===St.FORWARD){const F=b();if(F){if(n.push(F),_.occupyCoordinates(F),a=F,Number.isNaN(F.x)||Number.isNaN(F.y))return d=St.DONE,e.onPointAdded(void 0,void 0,void 0),!0;if(T(F))return}else e.forwardOnly?d=St.DONE:(a=m,d=St.BACKWARD,e.onPointAdded(void 0,void 0,void 0))}if(d===St.BACKWARD){const F=N();if(F){if(n.unshift(F),a=F,_.occupyCoordinates(F),Number.isNaN(F.x)||Number.isNaN(F.y))return d=St.DONE,e.onPointAdded(void 0,void 0,void 0),!0;if(T(F))return}else d=St.DONE}if(d===St.DONE)return n.forEach(v),e.onPointAdded(void 0,void 0,void 0),!0}},getStreamline:()=>n,getNextValidSeed:function(){for(;g<n.length-1;){g+=1;const F=n[g],j=B(F);if(!j)continue;let H=F.x-j.y*e.dSep,nt=F.y+j.x*e.dSep;if(Array.isArray(e.seedArray)&&e.seedArray.length>0){const tt=e.seedArray.shift();H=tt.x,nt=tt.y}if(!t.isOutside(H,nt)&&!t.isTaken(H,nt,w))return g-=1,new _t(H,nt);const it=F.x+j.y*e.dSep,Y=F.y-j.x*e.dSep;if(!t.isOutside(it,Y)&&!t.isTaken(it,Y,w))return new _t(it,Y)}}};function x(F){return!Et(F,e.dTest)&&F<e.dTest}function w(F){return!Et(F,e.dSep)&&F<e.dSep}function v(F){t.occupyCoordinates(F)}function b(){const F=Ye(a,e.timeStep,B);if(F)return E(a,F)}function N(){let F=Ye(a,e.timeStep,B);if(F)return F=F.mulScalar(-1),E(a,F)}function E(F,j){if(p=F.add(j),!t.isOutside(p.x,p.y)&&!t.isTaken(p.x,p.y,x)&&!_.isTaken(p.x,p.y,I))return p}function I(F){return F<.9*e.timeStep}function T(F){let j=!1;if(e.onPointAdded){const H=n[d===St.FORWARD?n.length-2:1];j=e.onPointAdded(F,H,e)}return j}function B(F){const j=e.vectorField(F);if(!j||Number.isNaN(j.x)||Number.isNaN(j.y))return;let H=j.x**2+j.y**2;return H!==0?(H=Math.sqrt(H),new _t(j.x/H,j.y/H)):void 0}}function Et(m,t){return Math.abs(m-t)<1e-4}function ze(m,t){if(typeof m!="number"||Number.isNaN(m))throw new Error(t)}function Ue({vectorField:m,isOutsideFct:t,bounds:e,seed:n,seedArray:a,maximumPointsPerLine:d,stepsPerIteration:p=50,timeStep:g=.05,dSep:_=.2,dTest:x=.08,forwardOnly:w=!1}){const v=[];let b=[];return(function(N){const E=N;if(!N)throw new Error("Configuration is required to compute streamlines");if(!N.boundingBox)throw new Error("No bounding box passed to streamline. Creating default one");(function(Y){const tt="Bounding box {left, top, width, height} is required";if(!Y)throw new Error(tt);if(ze(Y.left,tt),ze(Y.top,tt),typeof Y.size=="number"&&(Y.width=Y.size,Y.height=Y.size),ze(Y.width,tt),ze(Y.height,tt),Y.width<=0||Y.height<=0)throw new Error("Bounding box cannot be empty")})(E.boundingBox);const I=E.boundingBox;if(N.seedArray!==void 0&&Array.isArray(N.seedArray)){const Y=N.seedArray.shift();E.seed=new _t(Y.x,Y.y),E.seedArray=N.seedArray}else N.seed!==void 0?E.seed=N.seed:E.seed=new _t(Math.random()*I.width+I.left,Math.random()*I.height+I.top);E.dSep=N.dSep>0?N.dSep:1/Math.max(I.width,I.height),E.dTest=N.dTest>0?N.dTest:.5*E.dSep;const T=Ht(I,E.dSep,E.isOutsideFct);E.timeStep=N.timeStep>0?N.timeStep:.01,E.stepsPerIteration=N.stepsPerIteration>0?N.stepsPerIteration:10,E.maxTimePerIteration=N.maxTimePerIteration>0?N.maxTimePerIteration:1e3;const B=E.stepsPerIteration;let F=yt.STATE_INIT;const j=[];let H=Ke(E.seed,T,E);return{run:function(){for(;F!==yt.STATE_DONE;)for(let Y=0;Y<B;++Y)F===yt.STATE_INIT?H.next()&&(it(),F=yt.STATE_PROCESS_QUEUE):F===yt.STATE_STREAMLINE?H.next()&&(it(),F=yt.STATE_SEED_STREAMLINE):F===yt.STATE_PROCESS_QUEUE?F=j.length===0?yt.STATE_DONE:yt.STATE_SEED_STREAMLINE:F===yt.STATE_SEED_STREAMLINE&&nt()}};function nt(){const Y=j[0].getNextValidSeed();Y?(H=Ke(Y,T,E),F=yt.STATE_STREAMLINE):(j.shift(),F=yt.STATE_PROCESS_QUEUE)}function it(){const Y=H.getStreamline();Y.length>1&&(j.push(H),E.onStreamlineAdded&&E.onStreamlineAdded(Y,E))}})({vectorField:m,isOutsideFct:t,onPointAdded:function(N,E){return N===void 0?(b.length>1&&v.push([...b]),b=[],!1):(b.push(N.x,N.y,0,E.x,E.y,0),!0)},onStreamlineAdded:void 0,maxTimePerIteration:1,maximumPointsPerLine:d,seed:n,boundingBox:{width:e[3]-e[0],height:e[4]-e[1],left:e[0],top:e[1]},stepsPerIteration:p,timeStep:g,dSep:_,dTest:x,forwardOnly:w,seedArray:a}).run(),b.length!==0&&v.push([...b]),v.map((N=>{const E=[];for(let I=0;I<N.length;I+=2)E.push(I,I+1);return R.DataFrame.create({series:{positions:R.Serie.create({array:N,itemSize:3}),indices:R.Serie.create({array:E,itemSize:2})}})}))}function Mt({positions:m,indices:t,vectorField:e,seeds:n,nx:a=100,ny:d=100,maximumPointsPerLine:p=50,dSep:g=.1,timeStep:_=.05,dTest:x=.05,maxTimePerIteration:w=1e3}){const v=new je((0,D.minMax)(m),.1),b=v.normalize(m),N=(0,D.minMax)(b),E=new Le({positions:b,indices:t,attribute:e,nx:a,ny:d,flatten:!0,scaling:1});let I;n&&(I=[],R.Serie.create({array:n,itemSize:3}).map((B=>v.normalize(B))).forEach((B=>I.push({x:B[0],y:B[1]}))));const T=Ue({vectorField:B=>{const F=E.interpolate([B.x,B.y]);if(F!==void 0)return new _t(F[0],F[1])},bounds:N,maximumPointsPerLine:p,dSep:g,timeStep:_,dTest:x,seedArray:I});return T.forEach((B=>{B.series.positions=v.denormalize(B.series.positions)})),T}function Ce({positions:m,indices:t,serie:e}){const n=Pt.create(m,t);if(e.count!==n.nbFacets)throw new Error(`serie must be defined at triangles (count=${n.nbFacets}). Got count=${e.itemSize}`);const a=e.itemSize,d=e.newInstance({count:n.nbNodes,itemSize:a}).array,p=new Array(n.nbNodes).fill(0);n.forEachFace(((g,_)=>{const x=g.nodeIds,w=e.itemAt(_);for(let v=0;v<3;++v){const b=x[v];if(a===1)d[b]+=w;else for(let N=0;N<a;++N)d[a*b+N]+=w[N];p[b]++}}));for(let g=0,_=0;g<d.length;g+=a,++_)for(let x=0;x<a;++x)d[g+x]/=p[_];return R.Serie.create({array:d,itemSize:a})}function ni({positions:m,indices:t,serie:e}){const n=Pt.create(m,t);if(e.count!==n.nbNodes)throw new Error(`serie must be defined at nodes (count=${n.nbNodes}). Got count=${e.itemSize}`);const a=e.itemSize,d=e.newInstance({count:n.nbFacets,itemSize:a}).array;n.forEachFace(((p,g)=>{const _=p.nodeIds;for(let x=0;x<3;++x){const w=e.itemAt(_[x]);if(a===1)d[g]+=w;else for(let v=0;v<a;++v)d[a*g+v]+=w[v]}}));for(let p=0;p<d.length;++p)d[p]/=3;return R.Serie.create({array:d,itemSize:a})}(function(m){m[m.FORWARD=0]="FORWARD",m[m.BACKWARD=1]="BACKWARD",m[m.DONE=2]="DONE"})(St||(St={})),(function(m){m[m.STATE_INIT=0]="STATE_INIT",m[m.STATE_STREAMLINE=1]="STATE_STREAMLINE",m[m.STATE_PROCESS_QUEUE=2]="STATE_PROCESS_QUEUE",m[m.STATE_DONE=3]="STATE_DONE",m[m.STATE_SEED_STREAMLINE=4]="STATE_SEED_STREAMLINE"})(yt||(yt={}));class te extends D.NormalsDecomposer{serie(t,e,n){const a=super.serie(t,e,n);if(a)return Ce({positions:t.series.positions,indices:t.series.indices,serie:a})}}class mt{constructor({positions:t,indices:e,decomposer:n}){this.positions=t,this.indices=e,this.decomposer=n}names(t,e,n,a){return this.decomposer.names(t,e,n,a)}serie(t,e,n){return this.decomposer.serie(t,e,n)?Ce({positions:this.positions,indices:this.indices,serie:this.decomposer.serie(t,e,n)}):void 0}}class oi{constructor({positions:t,indices:e,names:n}){if(this.names_=["k1","k2","H","K"],t&&e&&(this.geo=new h(t,e,!0)),n!==void 0){if(n.length!==4)throw new Error("curvature names length must be 4 (principal 1, principal 2, mean, gaussian)");this.names_=n}}names(t,e,n,a){return e!==1||this.geo===void 0?[]:this.names_}serie(t,e,n){if(this.names_.includes(n))switch(n){case this.names_[0]:return this.geo.k1();case this.names_[1]:return this.geo.k2();case this.names_[2]:return this.geo.H();case this.names_[3]:return this.geo.K();default:return}}}class $t{constructor(){this.vertex=void 0,this.edge=void 0,this.face=void 0,this.corner=void 0,this.next=void 0,this.prev=void 0,this.twin=void 0,this.onBoundary=!1,this.index=-1}toString(){return this.index}}class ht{constructor(){this.halfedge=void 0,this.index=-1}onBoundary(){return this.halfedge.onBoundary||this.halfedge.twin.onBoundary}toString(){return this.index}}class We{constructor(){this.halfedge=void 0,this.index=-1}isBoundaryLoop(){return this.halfedge.onBoundary}adjacentVertices(t=!0){return new It(this.halfedge,t)}adjacentEdges(t=!0){return new ai(this.halfedge,t)}adjacentFaces(t=!0){return new Xe(this.halfedge,t)}adjacentHalfedges(t=!0){return new st(this.halfedge,t)}adjacentCorners(t=!0){return new hi(this.halfedge,t)}toString(){return this.index}}class It{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.vertex;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:t}}return{done:!0}}}}}class ai{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.edge;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:t}}return{done:!0}}}}}class Xe{constructor(t,e){for(;t.twin.onBoundary;)t=t.next;this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){for(;this.current.twin.onBoundary;)this.current=this.ccw?this.current.next:this.current.prev;if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.twin.face;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:t}}return{done:!0}}}}}class st{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current;return this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:t}}return{done:!0}}}}}class hi{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){return this.justStarted||this.current!==this.end?(this.justStarted=!1,this.current=this.ccw?this.current.next:this.current.prev,{done:!1,value:this.current.corner}):{done:!0}}}}}class qt{constructor(){this.halfedge=void 0,this.index=-1}degree(){let t=0;for(const e of this.adjacentEdges())t++;return t}isIsolated(){return this.halfedge===void 0}onBoundary(){for(const t of this.adjacentHalfedges())if(t.onBoundary)return!0;return!1}adjacentVertices(t=!0){return new pt(this.halfedge,t)}adjacentEdges(t=!0){return new ci(this.halfedge,t)}adjacentFaces(t=!0){return new Ft(this.halfedge,t)}adjacentHalfedges(t=!0){return new Ee(this.halfedge,t)}adjacentCorners(t=!0){return new ui(this.halfedge,t)}toString(){return this.index}}class pt{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.twin.vertex;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:t}}return{done:!0}}}}}class ci{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.edge;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:t}}return{done:!0}}}}}class Ft{constructor(t,e){for(;t.onBoundary;)t=t.twin.next;this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){for(;this.current.onBoundary;)this.current=this.ccw?this.current.twin.next:this.current.prev.twin;if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.face;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:t}}return{done:!0}}}}}class Ee{constructor(t,e){this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:t}}return{done:!0}}}}}class ui{constructor(t,e){for(;t.onBoundary;)t=t.twin.next;this._halfedge=t,this._ccw=e}[Symbol.iterator](){return{current:this._halfedge,end:this._halfedge,ccw:this._ccw,justStarted:!0,next(){for(;this.current.onBoundary;)this.current=this.ccw?this.current.twin.next:this.current.prev.twin;if(this.justStarted||this.current!==this.end){this.justStarted=!1;const t=this.current.next.corner;return this.current=this.ccw?this.current.twin.next:this.current.prev.twin,{done:!1,value:t}}return{done:!0}}}}}class di{constructor(){this.halfedge=void 0,this.halfedge=void 0,this.index=-1}get vertex(){return this.halfedge.prev.vertex}get face(){return this.halfedge.face}get next(){return this.halfedge.next.corner}get prev(){return this.halfedge.prev.corner}toString(){return this.index}}class l{constructor(){this.vertices=[],this.edges=[],this.faces=[],this.corners=[],this.halfedges=[],this.boundaries=[],this.generators=[],this.vertices=[],this.edges=[],this.faces=[],this.corners=[],this.halfedges=[],this.boundaries=[],this.generators=[]}eulerCharacteristic(){return this.vertices.length-this.edges.length+this.faces.length}build(t,e){this.preallocateElements(t,e);const n=new Map;for(let w=0;w<t.count;w++){const v=new qt;v.index=w,this.vertices[w]=v,n.set(w,v)}let a=0;const d=new Map,p=new Map,g=new Map;for(let w=0;w<e.array.length;w+=3){const v=new We;this.faces[w/3]=v;for(let b=0;b<3;b++){const N=new $t;this.halfedges[w+b]=N}for(let b=0;b<3;b++){const N=(b+1)%3;let E=e.array[w+b],I=e.array[w+N];const T=this.halfedges[w+b];T.next=this.halfedges[w+N],T.prev=this.halfedges[w+(b+3-1)%3],T.onBoundary=!1,g.set(T,!1);const B=n.get(E);T.vertex=B,B.halfedge=T,T.face=v,v.halfedge=T,E>I&&(I=[E,E=I][0]);const F=[E,I].toString();if(p.has(F)){const j=p.get(F);T.twin=j,j.twin=T,T.edge=j.edge,g.set(T,!0),g.set(j,!0),d.set(F,d.get(F)+1)}else{const j=new ht;this.edges[a++]=j,T.edge=j,j.halfedge=T,p.set(F,T),d.set(F,1)}if(d.get(F)>2)return console.warn("Mesh has non-manifold edges!"),!1}}let _=e.array.length,x=0;for(let w=0;w<e.array.length;w++){const v=this.halfedges[w];if(!g.get(v)){const b=new We;this.boundaries.push(b);const N=[];let E=v;do{const T=new $t;this.halfedges[_++]=T,N.push(T);let B=E.next;for(;g.get(B);)B=B.twin.next;T.vertex=B.vertex,T.edge=E.edge,T.onBoundary=!0,T.face=b,b.halfedge=T,T.twin=E,E.twin=T,E=B}while(E!==v);const I=N.length;for(let T=0;T<I;T++)N[T].next=N[(T+I-1)%I],N[T].prev=N[(T+1)%I],g.set(N[T],!0),g.set(N[T].twin,!0)}if(!v.onBoundary){const b=new di;b.halfedge=v,v.corner=b,this.corners[x++]=b}}return!(this.hasIsolatedVertices()||this.hasIsolatedFaces()||this.hasNonManifoldVertices()||(this.indexElements(),0))}preallocateElements(t,e){let n=0;const a=new Map;for(let w=0;w<e.array.length;w+=3)for(let v=0;v<3;v++){const b=(v+1)%3;let N=e.array[w+v],E=e.array[w+b];N>E&&(E=[N,N=E][0]);const I=[N,E],T=I.toString();a.has(T)?n--:(a.set(T,I),n++)}const d=t.count,p=a.size,g=e.count,_=2*p,x=_-n;this.vertices.length=0,this.edges.length=0,this.faces.length=0,this.halfedges.length=0,this.corners.length=0,this.boundaries.length=0,this.generators.length=0,this.vertices=new Array(d),this.edges=new Array(p),this.faces=new Array(g),this.halfedges=new Array(_),this.corners=new Array(x)}hasIsolatedVertices(){for(const t of this.vertices)if(t.isIsolated())return console.warn("Mesh has isolated vertices!"),!0;return!1}hasIsolatedFaces(){for(const t of this.faces){let e=0;for(const n of t.adjacentHalfedges())n.twin.onBoundary&&e++;if(e===3)return console.warn("Mesh has isolated faces!"),!0}return!1}hasNonManifoldVertices(){const t=new Map;for(const e of this.vertices)t.set(e,0);for(const e of this.faces)for(const n of e.adjacentVertices())t.set(n,t.get(n)+1);for(const e of this.boundaries)for(const n of e.adjacentVertices())t.set(n,t.get(n)+1);for(const e of this.vertices)if(t.get(e)!==e.degree())return!0;return!1}indexElements(){let t=0;for(const e of this.vertices)e.index=t++;t=0;for(const e of this.edges)e.index=t++;t=0;for(const e of this.faces)e.index=t++;t=0;for(const e of this.halfedges)e.index=t++;t=0;for(const e of this.corners)e.index=t++;t=0;for(const e of this.boundaries)e.index=t++}}class h{constructor(t,e,n=!0){this.mesh=new l,this.mesh.build(t,e),this.positions=t,n&&(function(a,d,p=!0){const g=d.length,_=new u;for(const w of d){const v=a.itemAt(w.index);_.incrementBy(v)}_.divideBy(g);let x=-1;for(const w of d){const v=new u(a.itemAt(w.index));v.decrementBy(_),x=Math.max(x,v.norm())}if(p)for(const w of d)new u(a.itemAt(w.index)).divideBy(x)})(this.positions,this.mesh.vertices)}vector(t){const e=this.pos(t.vertex);return this.pos(t.next.vertex).minus(e)}length(t){return this.vector(t.halfedge).norm()}pos(t){return new u(this.positions.itemAt(t.index))}midpoint(t){const e=t.halfedge,n=this.pos(e.vertex),a=this.pos(e.twin.vertex);return n.plus(a).over(2)}meanEdgeLength(){let t=0;const e=this.mesh.edges;for(const n of e)t+=this.length(n);return t/e.length}area(t){if(t.isBoundaryLoop())return 0;const e=this.vector(t.halfedge),n=this.vector(t.halfedge.prev).negated();return .5*e.cross(n).norm()}totalArea(){let t=0;for(const e of this.mesh.faces)t+=this.area(e);return t}faceNormal(t){if(t.isBoundaryLoop())return;const e=this.vector(t.halfedge),n=this.vector(t.halfedge.prev).negated();return e.cross(n).unit()}centroid(t){const e=t.halfedge,n=this.pos(e.vertex),a=this.pos(e.next.vertex),d=this.pos(e.prev.vertex);return t.isBoundaryLoop()?n.plus(a).over(2):n.plus(a).plus(d).over(3)}circumcenter(t){const e=t.halfedge,n=this.pos(e.vertex),a=this.pos(e.next.vertex),d=this.pos(e.prev.vertex);if(t.isBoundaryLoop())return n.plus(a).over(2);const p=d.minus(n),g=a.minus(n),_=g.cross(p),x=_.cross(g).times(p.norm2()),w=p.cross(_).times(g.norm2());return x.plus(w).over(2*_.norm2()).plus(n)}orthonormalBases(t){const e=this.vector(t.halfedge).unit();return[e,this.faceNormal(t).cross(e)]}angle(t){const e=this.vector(t.halfedge.prev).unit(),n=this.vector(t.halfedge.next).negated().unit();return Math.acos(Math.max(-1,Math.min(1,e.dot(n))))}cotan(t){if(t.onBoundary)return 0;const e=this.vector(t.prev),n=this.vector(t.next).negated();return e.dot(n)/e.cross(n).norm()}dihedralAngle(t){if(t.onBoundary||t.twin.onBoundary)return 0;const e=this.faceNormal(t.face),n=this.faceNormal(t.twin.face),a=this.vector(t).unit(),d=e.dot(n),p=e.cross(n).dot(a);return Math.atan2(p,d)}barycentricDualArea(t){let e=0;for(const n of t.adjacentFaces())e+=this.area(n)/3;return e}circumcentricDualArea(t){let e=0;for(const n of t.adjacentHalfedges()){const a=this.vector(n.prev).norm2(),d=this.vector(n).norm2();e+=(a*this.cotan(n.prev)+d*this.cotan(n))/8}return e}vertexNormalEquallyWeighted(t){const e=new u;for(const n of t.adjacentFaces()){const a=this.faceNormal(n);e.incrementBy(a)}return e.normalize(),e}vertexNormalAreaWeighted(t){const e=new u;for(const n of t.adjacentFaces()){const a=this.faceNormal(n),d=this.area(n);e.incrementBy(a.times(d))}return e.normalize(),e}vertexNormalAngleWeighted(t){const e=new u;for(const n of t.adjacentCorners()){const a=this.faceNormal(n.halfedge.face),d=this.angle(n);e.incrementBy(a.times(d))}return e.normalize(),e}vertexNormalGaussCurvature(t){const e=new u;for(const n of t.adjacentHalfedges()){const a=.5*this.dihedralAngle(n)/this.length(n.edge);e.decrementBy(this.vector(n).times(a))}return e.normalize(),e}vertexNormalMeanCurvature(t){const e=new u;for(const n of t.adjacentHalfedges()){const a=.5*(this.cotan(n)+this.cotan(n.twin));e.decrementBy(this.vector(n).times(a))}return e.normalize(),e}vertexNormalSphereInscribed(t){const e=new u;for(const n of t.adjacentCorners()){const a=this.vector(n.halfedge.prev),d=this.vector(n.halfedge.next).negated();e.incrementBy(a.cross(d).over(a.norm2()*d.norm2()))}return e.normalize(),e}angleDefect(t){let e=0;for(const n of t.adjacentCorners())e+=this.angle(n);return t.onBoundary()?Math.PI-e:2*Math.PI-e}totalAngleDefect(){let t=0;for(const e of this.mesh.vertices)t+=this.angleDefect(e);return t}scalarGaussCurvature(t){return this.angleDefect(t)}scalarMeanCurvature(t){let e=0;for(const n of t.adjacentHalfedges())e+=.5*this.length(n.edge)*this.dihedralAngle(n);return e}principalCurvatures(t){const e=this.circumcentricDualArea(t),n=this.scalarMeanCurvature(t)/e;let a=n*n-this.angleDefect(t)/e;return a=a>0?Math.sqrt(a):0,[n-a,n+a]}K(){return R.Serie.create({array:this.mesh.vertices.map((t=>this.angleDefect(t))),itemSize:1})}H(){return R.Serie.create({array:this.mesh.vertices.map((t=>this.scalarMeanCurvature(t))),itemSize:1})}k1(){const t=this.mesh.vertices.map((e=>this.principalCurvatures(e)[0]));return R.Serie.create({array:t,itemSize:1})}k2(){const t=this.mesh.vertices.map((e=>this.principalCurvatures(e)[1]));return R.Serie.create({array:t,itemSize:1})}}class u{constructor(t=0,e,n){Array.isArray(t)?(this.x=t[0],this.y=t[1],this.z=t[2]):(this.x=t,this.y=e!==void 0?e:0,this.z=n!==void 0?n:0)}norm(){return Math.sqrt(this.norm2())}norm2(){return this.dot(this)}normalize(){const t=this.norm();this.x/=t,this.y/=t,this.z/=t}unit(){const t=this.norm(),e=this.x/t,n=this.y/t,a=this.z/t;return new u(e,n,a)}isValid(){return!isNaN(this.x)&&!isNaN(this.y)&&!isNaN(this.z)&&isFinite(this.x)&&isFinite(this.y)&&isFinite(this.z)}incrementBy(t){Array.isArray(t)?(this.x+=t[0],this.y+=t[1],this.z+=t[2]):(this.x+=t.x,this.y+=t.y,this.z+=t.z)}decrementBy(t){Array.isArray(t)?(this.x-=t[0],this.y-=t[1],this.z-=t[2]):(this.x-=t.x,this.y-=t.y,this.z-=t.z)}scaleBy(t){this.x*=t,this.y*=t,this.z*=t}divideBy(t){this.scaleBy(1/t)}plus(t){return new u(this.x+t.x,this.y+t.y,this.z+t.z)}minus(t){return new u(this.x-t.x,this.y-t.y,this.z-t.z)}times(t){return new u(this.x*t,this.y*t,this.z*t)}over(t){return this.times(1/t)}negated(){return this.times(-1)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new u(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}}function i(m){const t=new U;return m.forEach((e=>t.grow(e))),t}class r{constructor(t,e){this.x=0,this.y=0,this.x=t,this.y=e}dot(t){return this.x*t.x+this.y*t.y}add(t){return new r(this.x+t.x,this.y+t.y)}sub(t){return new r(this.x-t.x,this.y-t.y)}scale(t){return new r(this.x*t,this.y*t)}sqDistanceTo(t){return(this.x-t.x)*(this.x-t.x)+(this.y-t.y)*(this.y-t.y)}toStr(){return"("+this.x.toFixed(3)+", "+this.y.toFixed(3)+")"}copyFrom(t){this.x=t.x,this.y=t.y}}function s(m,t){return m.x*t.y-m.y*t.x}function o(m,t){const e=m[1].sub(m[0]),n=t[0].sub(m[0]),a=t[1].sub(m[0]),d=s(e,n),p=s(e,a);if(d>0&&p>0||d<0&&p<0)return!1;const g=t[1].sub(t[0]),_=m[0].sub(t[0]),x=m[1].sub(t[0]),w=s(g,_),v=s(g,x);return!(w>0&&v>0||w<0&&v<0||Math.abs(d)<1e-14&&Math.abs(p)<1e-14&&(Math.max(t[0].x,t[1].x)<Math.min(m[0].x,m[1].x)||Math.min(t[0].x,t[1].x)>Math.max(m[0].x,m[1].x)||Math.max(t[0].y,t[1].y)<Math.min(m[0].y,m[1].y)||Math.min(t[0].y,t[1].y)>Math.max(m[0].y,m[1].y)))}function c(m,t){return s(m[1].sub(m[0]),t.sub(m[0]))}class f{constructor(t=void 0,e=void 0){this.min_coord=new r(0,0),this.max_coord=new r(1,1),this.vert=[],this.scaled_vert=[],this.con_edge=[],this.vert_to_tri=[],this.bin=[],this.tri=[],this.adj=[],this.screenL=1,t&&e&&this.build(t,e)}build(t,e){this.setVertices(t),this.setEdges(e),this.scaled_vert=[],this.vert_to_tri=[],this.bin=[],this.tri=[],this.adj=[],this.triangulate()}get triangles(){return this.tri}triangulate(){if(this.vert.length===0)return void y("No input vertices to triangulate.");let t=performance.now();this.delaunay();let e=performance.now()-t;this.con_edge.length>0?(t=performance.now(),this.constrainEdges(),y("Computed cdt in "+(e+(performance.now()-t)).toFixed(2)+" ms.")):y("cdt in "+e.toFixed(2)+" ms.")}setVertices(t){if(t.itemSize!==2&&t.itemSize!==3)throw new Error("vertices must be defined with itemSize = 2 or 3 (coordinates in 2D or 3D)");this.vert=[],this.min_coord=new r(Number.MAX_VALUE,Number.MAX_VALUE),this.max_coord=new r(-Number.MAX_VALUE,-Number.MAX_VALUE),t.forEach((e=>{let n=new r(Number(e[0]),Number(e[1]));this.vert.push(n),this.min_coord.x=Math.min(this.min_coord.x,n.x),this.min_coord.y=Math.min(this.min_coord.y,n.y),this.max_coord.x=Math.max(this.max_coord.x,n.x),this.max_coord.y=Math.max(this.max_coord.y,n.y)})),this.screenL=Math.max(this.max_coord.x-this.min_coord.x,this.max_coord.y-this.min_coord.y)}setEdges(t){if(t.itemSize!==2)throw new Error("edges must be defined with itemSize = 2 (two vertex ids making the constrained edges)");const e=this.vert.length;this.con_edge=[],t.forEach(((n,a)=>{if(n[0]<0||n[0]>=e||n[1]<0||n[1]>=e)throw new Error(`Vertex indices of edge ${a} (${n}) need to be non-negative and less than the number of input vertices (${e}).`);if(n[0]===n[1])throw new Error(`Edge ${a} is degenerate!`);const d=[n[0],n[1]];if(!this.isEdgeValid(d))throw new Error(`Edge ${a} already exists or intersects with an existing edge!`);this.con_edge.push(d)}))}isEdgeValid(t){const e=this.con_edge,n=this.vert,a=[n[t[0]],n[t[1]]];for(let d=0;d<e.length;d++){if(e[d][0]==t[0]&&e[d][1]==t[1]||e[d][0]==t[1]&&e[d][1]==t[0])return!1;let p=e[d][0]==t[0]||e[d][0]==t[1]||e[d][1]==t[0]||e[d][1]==t[1],g=[n[e[d][0]],n[e[d][1]]];if(!p&&o(g,a))return!1}return!0}binSorter(t,e){return t.bin==e.bin?0:t.bin<e.bin?-1:1}setupDelaunay(){const t=this.vert.length,e=Math.round(Math.pow(t,.25));var n=[],a=[];for(let p=0;p<t;p++){const g=(this.vert[p].x-this.min_coord.x)/this.screenL,_=(this.vert[p].y-this.min_coord.y)/this.screenL;n.push(new r(g,_));const x=Math.round((e-1)*g),w=Math.round((e-1)*_);let v=0;v=w%2==0?w*e+x:(w+1)*e-x-1,a.push({ind:p,bin:v})}const d=S;n.push(new r(.5-d,-d/Math.sqrt(3)+.5)),n.push(new r(d+.5,-d/Math.sqrt(3)+.5)),n.push(new r(.5,2*d/Math.sqrt(3)+.5));for(let p=t;p<t+3;p++)this.vert.push(new r(this.screenL*n[p].x+this.min_coord.x,this.screenL*n[p].y+this.min_coord.y));a.sort(this.binSorter),this.scaled_vert=n,this.bin=a,this.tri=[[t,t+1,t+2]],this.adj=[[-1,-1,-1]],this.vert_to_tri=[]}delaunay(){this.setupDelaunay();const t=this.scaled_vert,e=this.bin,n=this.tri,a=this.adj,d=t.length-3;let p=0,g=0;for(let _=0;_<d;_++){const x=e[_].ind,w=this.findEnclosingTriangle(t[x],p);if(p=w[0],g+=w[1],p===-1)throw new Error("Could not find a triangle containing the new vertex!");let v=n[p],b=[v[0],v[1],x],N=[x,v[1],v[2]],E=[v[0],x,v[2]];n[p]=b;const I=n.length,T=a[p];a[p]=[I,I+1,T[2]],n.push(N),n.push(E),a.push([T[0],I+1,p]),a.push([I,T[1],p]);let B=[];if(T[2]>=0){const F=a[T[2]].indexOf(p);B.push([T[2],F])}if(T[0]>=0){const F=a[T[0]].indexOf(p);a[T[0]][F]=I,B.push([T[0],F])}if(T[1]>=0){const F=a[T[1]].indexOf(p);a[T[1]][F]=I+1,B.push([T[1],F])}this.restoreDelaunay(x,B)}this.removeBoundaryTriangles()}findEnclosingTriangle(t,e){var n=this.scaled_vert,a=this.tri,d=this.adj;const p=Math.max(10,d.length);for(var g=0,_=[];g<p;){if(e===-1)return[e,g];var x=a[e];const v=[c([n[x[1]],n[x[2]]],t),c([n[x[2]],n[x[0]]],t),c([n[x[0]],n[x[1]]],t)];if(v[0]>=0&&v[1]>=0&&v[2]>=0)return[e,g];var w=-1;for(let E=0;E<3;E++)if(v[E]>=0){w=E;break}const b=(w+1)%3,N=(w+2)%3;if(v[b]>=0&&v[N]<0)e=d[e][N],_[g]=n[x[w]].add(n[x[b]]).scale(.5);else if(v[b]<0&&v[N]>=0)e=d[e][b],_[g]=n[x[N]].add(n[x[w]]).scale(.5);else{const E=n[x[b]].sub(n[x[w]]),I=t.sub(n[x[w]]);E.dot(I)>0?(e=d[e][N],_[g]=n[x[w]].add(n[x[b]]).scale(.5)):(e=d[e][b],_[g]=n[x[N]].add(n[x[w]]).scale(.5))}g++}return y("Failed to locate triangle containing vertex ("+t.x.toFixed(4)+", "+t.y.toFixed(4)+"). Input vertices may be too close to each other."),[e,g-1]}restoreDelaunay(t,e){for(var n=this.scaled_vert,a=this.tri,d=this.adj,p=n[t];e.length>0;){const g=e.pop(),_=g[0],x=a[_];let w=[];for(let v=0;v<3;v++)w[v]=n[x[v]];if(!this.isDelaunay2(w,p)){const v=g[1],b=d[_][v];if(b<0)throw"negative index";this.swapDiagonal(_,b);const N=a[_].indexOf(t),E=d[_][N];if(E>=0){const B=d[E].indexOf(_);e.push([E,B])}const I=a[b].indexOf(t),T=d[b][I];if(T>=0){const B=d[T].indexOf(b);e.push([T,B])}}}}swapDiagonal(t,e){const n=this.tri,a=this.adj,d=this.vert_to_tri,p=a[t].indexOf(e),g=a[e].indexOf(t),_=(p+1)%3,x=(p+2)%3,w=(g+1)%3,v=(g+2)%3;n[t][x]=n[e][g],n[e][v]=n[t][p],a[t][p]=a[e][w],a[e][g]=a[t][_];const b=a[t][_];if(b>=0){const E=a[b].indexOf(t);a[b][E]=e}const N=a[e][w];if(N>=0){const E=a[N].indexOf(e);a[N][E]=t}if(a[t][_]=e,a[e][w]=t,d.length>0){d[n[t][p]].push(e),d[n[e][g]].push(t);let E=d[n[t][_]].indexOf(e);d[n[t][_]].splice(E,1),E=d[n[e][w]].indexOf(t),d[n[e][w]].splice(E,1)}}removeBoundaryTriangles(){var t=this.scaled_vert,e=this.tri,n=this.adj;const a=t.length-3;var d=0,p=[];for(let g=0;g<e.length;g++){let _=d;for(let w=g;w<e.length;w++){if(e[w][0]<a&&e[w][1]<a&&e[w][2]<a){p[g+d]=g;break}p[g+d]=-1,d++}let x=d-_;x>0&&(e.splice(g,x),n.splice(g,x))}for(let g=0;g<n.length;g++)for(let _=0;_<3;_++)n[g][_]=p[n[g][_]];this.scaled_vert.splice(-3,3),this.vert.splice(-3,3)}isDelaunay2(t,e){const n=t[0].sub(e),a=t[1].sub(e),d=t[2].sub(e),p=n.x*n.x+n.y*n.y,g=a.x*a.x+a.y*a.y,_=d.x*d.x+d.y*d.y;return!(n.x*(a.y*_-g*d.y)-n.y*(a.x*_-g*d.x)+p*(a.x*d.y-a.y*d.x)>0)}constrainEdges(){if(this.con_edge.length==0)return;this.buildVertexConnectivity();const t=this.con_edge,e=this.tri,n=this.scaled_vert,a=this.adj,d=this.vert_to_tri,p=[];for(let x=0;x<t.length;x++){let w=this.getEdgeIntersections(x),v=0;const b=Math.max(w.length,1);for(;w.length>0&&v<b;)this.fixEdgeIntersections(w,x,p),w=this.getEdgeIntersections(x),v++;if(w.length>0)throw new Error("Could not add edge "+x+" to triangulation after "+b+" iterations!")}for(;;){let x=0;for(let w=0;w<p.length;w++){const v=p[w];let b=!1;for(let j=0;j<t.length;j++)if(g=v,_=t[j],g[0]==_[0]&&g[1]==_[1]||g[1]==_[0]&&g[0]==_[1]){b=!0;break}if(b)continue;const N=d[v[0]];let E=0,I=[-1,-1];for(let j=0;j<N.length;j++){const H=e[N[j]];if((H[0]==v[1]||H[1]==v[1]||H[2]==v[1])&&(I[E]=N[j],E++,E==2))break}if(I[0]==-1)continue;const T=[n[e[I[0]][0]],n[e[I[0]][1]],n[e[I[0]][2]]],B=a[I[1]].indexOf(I[0]),F=n[e[I[1]][B]];if(!this.isDelaunay2(T,F)){const j=a[I[0]].indexOf(I[1]);this.swapDiagonal(I[0],I[1]),x++,p[w]=[e[I[0]][j],e[I[1]][B]]}}if(x==0)break}var g,_}buildVertexConnectivity(){var t=this.tri;this.vert_to_tri=[];var e=this.vert_to_tri;for(let n=0;n<t.length;n++)for(let a=0;a<3;a++)e[t[n][a]]==null?e[t[n][a]]=[n]:e[t[n][a]].push(n)}getEdgeIntersections(t){var e=this.tri,n=this.scaled_vert,a=this.adj,d=this.con_edge,p=this.vert_to_tri;const g=d[t][0],_=d[t][1],x=[n[g],n[_]],w=p[g];let v=!1,b=[];for(let N=0;N<w.length;N++){const E=e[w[N]],I=E.indexOf(g),T=(I+1)%3,B=(I+2)%3;if(_==E[T]){v=!0;break}if(_==E[B]){v=!0;break}if(o(x,[n[E[T]],n[E[B]]])){b.push([w[N],I]);break}}if(!v){if(b.length==0)throw"Cannot have no intersections!";for(;;){const N=b[b.length-1],E=a[N[0]][N[1]];if(e[E][0]==_||e[E][1]==_||e[E][2]==_)break;let I=a[E].indexOf(N[0]);if(I==-1)throw"Could not find edge!";const T=e[E];for(let B=1;B<3;B++){const F=(I+B+2)%3;if(o(x,[n[T[(I+B+1)%3]],n[T[F]]])){b.push([E,(I+B)%3]);break}}}}return b}fixEdgeIntersections(t,e,n){var a=this.tri,d=this.scaled_vert,p=this.adj,g=this.con_edge[e],_=[d[g[0]],d[g[1]]],x=t.length;for(let w=0;w<x;w++){const v=t[x-1-w][0],b=t[x-1-w][1],N=p[v][b],E=p[N].indexOf(v),I=d[a[v][b]],T=d[a[v][(b+1)%3]],B=d[a[N][E]];if(o([I,B],[T,d[a[v][(b+2)%3]]])){this.swapDiagonal(v,N);const F=[a[v][b],a[N][E]],j=[I,B];F[0]!=g[0]&&F[0]!=g[1]&&F[1]!=g[0]&&F[1]!=g[1]&&o(_,j)||n.push([F[0],F[1]])}}}}function y(m){console.log(m)}const S=1e3;function q(m,t){const e=new f(m,t),n=new Array(3*e.triangles.length).fill(0);return e.triangles.forEach(((a,d)=>{const p=3*d;n[p]=a[0],n[p+1]=a[1],n[p+2]=a[2]})),{positions:m,indices:R.Serie.create({array:(0,R.createTyped)(Int32Array,n,!1),itemSize:3})}}})(),J})()))})(mi)),mi.exports}Ii();
